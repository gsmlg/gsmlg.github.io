"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[719],{9719:function(e,n,t){t.d(n,{qA:function(){return g}});var r=t(7462),o=t(7294),a=t(8818),i=t(9477);class s extends i.DataTextureLoader{constructor(e){super(e),this.type=i.HalfFloatType}parse(e){const n=function(e,n){switch(e){case 1:console.error("THREE.RGBELoader Read Error: "+(n||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(n||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(n||""));break;default:console.error("THREE.RGBELoader: Error: "+(n||""))}return-1},t=function(e,n,t){n=n||1024;let r=e.pos,o=-1,a=0,i="",s=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));for(;0>(o=s.indexOf("\n"))&&a<n&&r<e.byteLength;)i+=s,a+=s.length,r+=128,s+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));return-1<o&&(!1!==t&&(e.pos+=a+o+1),i+s.slice(0,o))},r=function(e,n,t,r){const o=e[n+3],a=Math.pow(2,o-128)/255;t[r+0]=e[n+0]*a,t[r+1]=e[n+1]*a,t[r+2]=e[n+2]*a,t[r+3]=1},o=function(e,n,t,r){const o=e[n+3],a=Math.pow(2,o-128)/255;t[r+0]=i.DataUtils.toHalfFloat(Math.min(e[n+0]*a,65504)),t[r+1]=i.DataUtils.toHalfFloat(Math.min(e[n+1]*a,65504)),t[r+2]=i.DataUtils.toHalfFloat(Math.min(e[n+2]*a,65504)),t[r+3]=i.DataUtils.toHalfFloat(1)},a=new Uint8Array(e);a.pos=0;const s=function(e){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,i=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(e.pos>=e.byteLength||!(l=t(e)))return n(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return n(3,"bad initial token");for(s.valid|=1,s.programtype=c[1],s.string+=l+"\n";l=t(e),!1!==l;)if(s.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(r))&&(s.gamma=parseFloat(c[1])),(c=l.match(o))&&(s.exposure=parseFloat(c[1])),(c=l.match(a))&&(s.valid|=2,s.format=c[1]),(c=l.match(i))&&(s.valid|=4,s.height=parseInt(c[1],10),s.width=parseInt(c[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=l+"\n";return 2&s.valid?4&s.valid?s:n(3,"missing image size specifier"):n(3,"missing format specifier")}(a);if(-1!==s){const e=s.width,t=s.height,l=function(e,t,r){const o=t;if(o<8||o>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);if(o!==(e[2]<<8|e[3]))return n(3,"wrong scanline width");const a=new Uint8Array(4*t*r);if(!a.length)return n(4,"unable to allocate buffer space");let i=0,s=0;const l=4*o,c=new Uint8Array(4),u=new Uint8Array(l);let d=r;for(;d>0&&s<e.byteLength;){if(s+4>e.byteLength)return n(1);if(c[0]=e[s++],c[1]=e[s++],c[2]=e[s++],c[3]=e[s++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=o)return n(3,"bad rgbe scanline format");let t,r=0;for(;r<l&&s<e.byteLength;){t=e[s++];const o=t>128;if(o&&(t-=128),0===t||r+t>l)return n(3,"bad scanline data");if(o){const n=e[s++];for(let e=0;e<t;e++)u[r++]=n}else u.set(e.subarray(s,s+t),r),r+=t,s+=t}const m=o;for(let e=0;e<m;e++){let n=0;a[i]=u[e+n],n+=o,a[i+1]=u[e+n],n+=o,a[i+2]=u[e+n],n+=o,a[i+3]=u[e+n],i+=4}d--}return a}(a.subarray(a.pos),e,t);if(-1!==l){let n,a,c,u;switch(this.type){case i.FloatType:u=l.length/4;const e=new Float32Array(4*u);for(let n=0;n<u;n++)r(l,4*n,e,4*n);n=e,c=i.FloatType;break;case i.HalfFloatType:u=l.length/4;const t=new Uint16Array(4*u);for(let n=0;n<u;n++)o(l,4*n,t,4*n);n=t,c=i.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:e,height:t,data:n,header:s.string,gamma:s.gamma,exposure:s.exposure,format:a,type:c}}}return null}setDataType(e){return this.type=e,this}load(e,n,t,r){return super.load(e,(function(e,t){switch(e.type){case i.FloatType:case i.HalfFloatType:e.encoding=i.LinearEncoding,e.minFilter=i.LinearFilter,e.magFilter=i.LinearFilter,e.generateMipmaps=!1,e.flipY=!0}n&&n(e,t)}),t,r)}}class l extends i.Mesh{constructor(e,n){var t,r;const o=(a=e)&&a.isCubeTexture;var a;const s=(null!=(t=o?null===(r=e.image[0])||void 0===r?void 0:r.width:e.image.width)?t:1024)/4,l=Math.floor(Math.log2(s)),c=Math.pow(2,l),u=[o?"#define ENVMAP_TYPE_CUBE":"","#define CUBEUV_TEXEL_WIDTH "+1/(3*Math.max(c,112)),"#define CUBEUV_TEXEL_HEIGHT "+1/(4*c),`#define CUBEUV_MAX_MIP ${l}.0`].join("\n")+"\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n        }\n        ",d={map:{value:e},height:{value:(null===n||void 0===n?void 0:n.height)||15},radius:{value:(null===n||void 0===n?void 0:n.radius)||100}};super(new i.IcosahedronGeometry(1,16),new i.ShaderMaterial({uniforms:d,fragmentShader:u,vertexShader:"\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",side:i.DoubleSide}))}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}const c={sunset:"venice/venice_sunset_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",night:"dikhololo/dikhololo_night_1k.hdr",warehouse:"empty-wharehouse/empty_warehouse_01_1k.hdr",forest:"forrest-slope/forest_slope_1k.hdr",apartment:"lebombo/lebombo_1k.hdr",studio:"studio-small-3/studio_small_03_1k.hdr",city:"potsdamer-platz/potsdamer_platz_1k.hdr",park:"rooitou/rooitou_park_1k.hdr",lobby:"st-fagans/st_fagans_interior_1k.hdr"},u=e=>{return(n=e).current&&n.current.isScene?e.current:e;var n};function d({scene:e,background:n=!1,map:t}){const r=(0,a.w)((e=>e.scene));return o.useLayoutEffect((()=>{if(t){const o=u(e||r),a=o.background,i=o.environment;return"only"!==n&&(o.environment=t),n&&(o.background=t),()=>{"only"!==n&&(o.environment=i),n&&(o.background=a)}}}),[r,e,t,n]),null}function m({files:e=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"],path:n="",preset:t,encoding:r,extensions:o}){if(t){if(!(t in c))throw new Error("Preset must be one of: "+Object.keys(c).join(", "));e=c[t],n="https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/"}const l=Array.isArray(e),u=l?i.CubeTextureLoader:s,d=(0,a.z)(u,l?[e]:e,(e=>{e.setPath(n),o&&o(e)})),m=l?d[0]:d;return m.mapping=l?i.CubeReflectionMapping:i.EquirectangularReflectionMapping,m.encoding=(null!==r&&void 0!==r?r:l)?i.sRGBEncoding:i.LinearEncoding,m}function f({background:e=!1,scene:n,...t}){const r=m(t),i=(0,a.w)((e=>e.scene));return o.useLayoutEffect((()=>{const t=u(n||i),o=t.background,a=t.environment;return"only"!==e&&(t.environment=r),e&&(t.background=r),()=>{"only"!==e&&(t.environment=a),e&&(t.background=o)}}),[r,e,n,i]),null}function p({children:e,near:n=1,far:t=1e3,resolution:r=256,frames:s=1,map:l,background:c=!1,scene:m,files:p,path:h,preset:g,extensions:v}){const E=(0,a.w)((e=>e.gl)),y=(0,a.w)((e=>e.scene)),b=o.useRef(null),[w]=o.useState((()=>new i.Scene)),_=o.useMemo((()=>{const e=new i.WebGLCubeRenderTarget(r);return e.texture.type=i.HalfFloatType,e}),[r]);o.useLayoutEffect((()=>{1===s&&b.current.update(E,w);const e=u(m||y),n=e.background,t=e.environment;return"only"!==c&&(e.environment=_.texture),c&&(e.background=_.texture),()=>{"only"!==c&&(e.environment=t),c&&(e.background=n)}}),[e,w,_.texture,m,y,c,s,E]);let k=1;return(0,a.x)((()=>{(s===1/0||k<s)&&(b.current.update(E,w),k++)})),o.createElement(o.Fragment,null,(0,a.g)(o.createElement(o.Fragment,null,e,o.createElement("cubeCamera",{ref:b,args:[n,t,_]}),p||g?o.createElement(f,{background:!0,files:p,preset:g,path:h,extensions:v}):l?o.createElement(d,{background:!0,map:l,extensions:v}):null),w))}function h(e){var n,t,i,s;const c=m(e),u=e.map||c;o.useMemo((()=>{(0,a.e)({GroundProjectedEnvImpl:l})}),[]);const f=o.useMemo((()=>[u]),[u]),p=null==(n=e.ground)?void 0:n.height,h=null==(t=e.ground)?void 0:t.radius,g=null!==(i=null==(s=e.ground)?void 0:s.scale)&&void 0!==i?i:1e3;return o.createElement(o.Fragment,null,o.createElement(d,(0,r.Z)({},e,{map:u})),o.createElement("groundProjectedEnvImpl",{args:f,scale:g,height:p,radius:h}))}function g(e){return e.ground?o.createElement(h,e):e.map?o.createElement(d,e):e.children?o.createElement(p,e):o.createElement(f,e)}}}]);