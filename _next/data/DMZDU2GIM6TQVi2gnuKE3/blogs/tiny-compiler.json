{"pageProps":{"slug":"tiny-compiler","blog":{"id":47,"name":"tiny-compiler","title":"了解Compiler, Tiny compiler","date":"2020-08-02","author":"Gao","content":"构建一个简单的编译器, 将 List 格式的代码转换成 C 格式的\n\n原始代码\n\n```lisp\n(plus 3 (abstract 9 6))\n```\n\n### 编译器\n\n一个编译器的前端模型\n\n![A Compiler's Frontend](./tiny-compiler/compiler-frontend.jpg)\n\n根据编译过程来解决这个问题\n\n1. 生成`tokens`\n2. 根据`tokens`生成`ast`\n3. 转换`ast`到`newAst`\n4. 从`newAst`生成代码\n\n### Tokenizer\n\n将源代码转换为`token`流\n\n```js\nconst tokenizer = input => {\n  let pos = 0;\n  let tokens = [];\n  while (pos < input.length) {\n    let char = input[pos];\n\n    const PAREN_MATCH = /[\\(\\)]/;\n    if (PAREN_MATCH.test(char)) {\n      tokens.push({ type: 'paren', value: char });\n      pos++;\n      continue;\n    }\n\n    const NAME_MATCH = /[a-zA-Z_]/;\n    const NAME_MATCH_ = /[a-zA-Z0-9_]/;\n    if (NAME_MATCH.test(char)) {\n      let verb = char;\n      while (NAME_MATCH_.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({ type: 'name', value: verb });\n      continue;\n    }\n\n    const NUM_MATCH = /[0-9]/;\n    if (NUM_MATCH.test(char)) {\n      let verb = char;\n      while (NUM_MATCH.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({ type: 'number', value: verb });\n      continue;\n    }\n\n    const WHITE_SPACE = /\\s/;\n    if (WHITE_SPACE.test(char)) {\n      pos++;\n      continue;\n    }\n    throw new Error(`Unexpect token at ${pos}`);\n  }\n  return tokens;\n};\n\nmodule.exports = tokenizer;\n```\n\n### Parser\n\n将`token`流转换为`AST`\n\n```js\nconst parser = tokens => {\n  let current = 0;\n\n  const walk = () => {\n    let token = tokens[current];\n\n    if (token.type === 'number') {\n      current++;\n\n      return {\n        type: 'NumberLiteral',\n        value: token.value,\n      };\n    }\n\n    if (token.type === 'paren' && token.value === '(') {\n      token = tokens[++current];\n\n      let node = {\n        type: 'CallExpression',\n        name: token.value,\n        params: [],\n      };\n\n      token = tokens[++current];\n\n      while (\n        token.type !== 'paren' ||\n        (token.type === 'paren' && token.value !== ')')\n      ) {\n        node.params.push(walk());\n        token = tokens[current];\n      }\n\n      current++;\n\n      return node;\n    }\n    throw new TypeError(token.type);\n  };\n\n  let ast = {\n    type: 'Program',\n    body: [],\n  };\n\n  while (current < tokens.length) {\n    ast.body.push(walk());\n  }\n\n  return ast;\n};\n\nmodule.exports = parser;\n```\n\n### Traverser and Transformer\n\n`Traverser` 提供了遍历 AST 的方法\n\n`Transformer` 通过 `Traverser` 遍历语法树来修改 `AST`\n\n#### Traverser\n\n```js\nconst traverser = (ast, visitor) => {\n  const traverseArray = (array, parent) => {\n    array.forEach(child => {\n      traverseNode(child, parent);\n    });\n  };\n\n  const traverseNode = (node, parent) => {\n    let methods = visitor[node.type];\n\n    if (methods && methods.enter) {\n      methods.enter(node, parent);\n    }\n\n    switch (node.type) {\n      case 'Program':\n        traverseArray(node.body, node);\n        break;\n\n      case 'CallExpression':\n        traverseArray(node.params, node);\n        break;\n\n      case 'NumberLiteral':\n        break;\n\n      default:\n        throw new TypeError(node.type);\n    }\n\n    if (methods && methods.exit) {\n      methods.exit(node, parent);\n    }\n  };\n\n  traverseNode(ast, null);\n};\n\nmodule.exports = traverser;\n```\n\n#### Transformer\n\n```js\nconst traverser = require('./traverser');\n\nconst transformer = ast => {\n  let newAst = {\n    type: 'Program',\n    body: [],\n  };\n\n  ast._context = newAst.body;\n\n  traverser(ast, {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value,\n        });\n      },\n    },\n    CallExpression: {\n      enter(node, parent) {\n        let expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: node.name,\n          },\n          arguments: [],\n        };\n\n        node._context = expression.arguments;\n\n        if (parent.type !== 'CallExpression') {\n          expression = {\n            type: 'ExpressionStatement',\n            expression: expression,\n          };\n        }\n\n        parent._context.push(expression);\n      },\n    },\n  });\n\n  return newAst;\n};\n\nmodule.exports = transformer;\n```\n\n### Code Generator\n\n将`AST`重新生成为代码\n\n```js\nconst codeGenerator = node => {\n  switch (node.type) {\n    case 'Program':\n      return node.body.map(codeGenerator).join('\\n');\n\n    case 'ExpressionStatement':\n      return codeGenerator(node.expression) + ';';\n\n    case 'CallExpression':\n      return (\n        codeGenerator(node.callee) +\n        '(' +\n        node.arguments.map(codeGenerator).join(', ') +\n        ')'\n      );\n\n    case 'Identifier':\n      return node.name;\n\n    case 'NumberLiteral':\n      return node.value;\n\n    default:\n      throw new TypeError(node.type);\n  }\n};\n\nmodule.exports = codeGenerator;\n```\n"}},"__N_SSG":true}