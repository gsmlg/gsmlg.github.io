{"pageProps":{"slug":"matrix-math","blog":{"author":"Gao","content":"# 矩阵变换计算\n\nWeb 3d中常常用到矩阵变换，这里记录一下矩阵变换的计算方式\n\n三维变换矩阵，这种矩阵由一个4x4方阵，共16个值组成。\n在JavaScript中，可以很方便的用数组表示矩阵。比如典型的单位矩阵。\n单位阵乘上一个点或者矩阵， 其结果保持不变。\n\n**单位矩阵**\n```javascript\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n```\n\n三维空间中的点和一个4x4矩阵并不匹配，加上了额外的第四维W。一般来说，把W设为1就可以了。\nW维度还有一些额外的用途（[WebGL model view projection - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection)）。\n\n矩阵与点的对齐\n```javascript\n[1, 0, 0, 0,\n 0, 1, 0, 0,\n 0, 0, 1, 0,\n 0, 0, 0, 1]\n\n[4, 3, 2, 1]\n```\n\n\n### 定义相乘函数\n\n**矩阵与点相乘**\n```javascript\nfunction multiplyMatrixAndPoint(matrix, point) {\n\n  // 给矩阵的每一部分一个简单的变量名, 列数（c）与行数（r）\n  var c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];\n  var c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];\n  var c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];\n  var c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\n\n  // 定义点坐标\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = point[3];\n\n  // 点坐标和第一列对应相乘, 再求和\n  var resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\n\n  // 点坐标和第二列对应相乘, 再求和\n  var resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\n\n  // 点坐标和第三列对应相乘, 再求和\n  var resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\n\n  // 点坐标和第四列对应相乘, 再求和\n  var resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\n\n  return [resultX, resultY, resultZ, resultW]\n}\n\n```\n\n可以使用这个函数将任意点乘以单位矩阵，还会返回这个点\n\n```javascript\n// identityResult等于[4,3,2,1]\nconst identityResult = multiplyMatrixAndPoint(identityMatrix, [4,3,2,1]);\n```\n\n**两个矩阵相乘**\n\n```javascript\nfunction multiplyMatrices(matrixA, matrixB) {\n\n  // 将第二个矩阵按列切片\n  var column0 = [matrixB[0], matrixB[4], matrixB[8], matrixB[12]];\n  var column1 = [matrixB[1], matrixB[5], matrixB[9], matrixB[13]];\n  var column2 = [matrixB[2], matrixB[6], matrixB[10], matrixB[14]];\n  var column3 = [matrixB[3], matrixB[7], matrixB[11], matrixB[15]];\n\n  // 将每列分别和矩阵相乘\n  var result0 = multiplyMatrixAndPoint( matrixA, column0 );\n  var result1 = multiplyMatrixAndPoint( matrixA, column1 );\n  var result2 = multiplyMatrixAndPoint( matrixA, column2 );\n  var result3 = multiplyMatrixAndPoint( matrixA, column3 );\n\n  // 把结果重新组合成矩阵\n  return [\n    result0[0], result1[0], result2[0], result3[0],\n    result0[1], result1[1], result2[1], result3[1],\n    result0[2], result1[2], result2[2], result3[2],\n    result0[3], result1[3], result2[3], result3[3]\n  ]\n}\n```\n\n实际计算\n```javascript\nconst someMatrix = [\n  4, 0, 0, 0,\n  0, 3, 0, 0,\n  0, 0, 5, 0,\n  4, 8, 4, 1\n]\n\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n// 返回someMatrix的数组表示\nconst someMatrixResult = multiplyMatrices(identityMatrix, someMatrix);\n```\n\n> 这些函数是为了介绍计算方式而创建的，计算过程创建了大量的数组，性能很差，真实场景计算需要使用TypedArray来做计算。可以使用矩阵计算库 [GitHub - toji/gl-matrix: Javascript Matrix and Vector library for High Performance WebGL apps](https://github.com/toji/gl-matrix)\n\n\n### 平移矩阵\n\n平移矩阵基于单位矩阵。它将一个对象沿x，y，z其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯。咖啡杯必须保持直立和朝向以免咖啡洒出来。它可以离开桌子在空间中移动。\n\n现在我们还喝不到这个杯子里的咖啡，因为在平移矩阵的单独作用下杯子并不能倾斜。在之后的部分，我们会讨论新的矩阵，来解决这个问题。\n\n```javascript\nconst x = 50;\nconst y = 100;\nconst z = 0;\n\nconst translationMatrix = [\n    1,    0,    0,   0,\n    0,    1,    0,   0,\n    0,    0,    1,   0,\n    x,    y,    z,   1\n];\n```\n\n### 缩放矩阵\n\n缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中， 这将使得x，y，z坐标拉伸或收缩。\n\n```javascript\nvar w = 1.5; // width  (x)\nvar h = 0.7; // height (y)\nvar d = 1;   // depth  (z)\n\nvar scaleMatrix = [\n    w,    0,    0,   0,\n    0,    h,    0,   0,\n    0,    0,    d,   0,\n    0,    0,    0,   1\n];\n```\n\n### 旋转矩阵\n\n```javascript\nconst { sin, cos } = Math;\n\nfunction rotateAroundXAxis(a) {\n\n  return [\n       1,       0,        0,     0,\n       0,  cos(a),  -sin(a),     0,\n       0,  sin(a),   cos(a),     0,\n       0,       0,        0,     1\n  ];\n}\n\nfunction rotateAroundYAxis(a) {\n\n  return [\n     cos(a),   0, sin(a),   0,\n          0,   1,      0,   0,\n    -sin(a),   0, cos(a),   0,\n          0,   0,      0,   1\n  ];\n}\n\nfunction rotateAroundZAxis(a) {\n\n  return [\n    cos(a), -sin(a),    0,    0,\n    sin(a),  cos(a),    0,    0,\n         0,       0,    1,    0,\n         0,       0,    0,    1\n  ];\n}\n```\n\n### 矩阵组合\n\n矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。\n\n矩阵相乘的结果与顺序有关。两个数相乘时，a * b = c, 和 b * a = c 都是正确的。例如，3 * 4 = 12, 和 4 * 3 = 12。在数学上这些数被称为**可交换**。矩阵不能保证交换顺序后的运算结果，所以矩阵是**不可交换**的。\n\n另一个需要记住的点是在WebGL和CSS3中的矩阵相乘需要和变换发生的顺序相反。例如，缩放对象到80%，向下移动200像素，然后绕原点旋转90度在伪代码中应该像下面这样。\n\n```javascript\ntransformation = rotate * translate * scale\n```\n\n","date":"2021-10-09","id":53,"slug":"matrix-math","title":"Web中的矩阵变换计算"},"lightCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#c18401}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}","darkCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},"__N_SSG":true}