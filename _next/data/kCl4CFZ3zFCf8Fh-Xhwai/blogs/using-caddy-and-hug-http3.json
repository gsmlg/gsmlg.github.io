{"pageProps":{"slug":"using-caddy-and-hug-http3","blog":{"id":55,"name":"using-caddy-and-hug-http3","title":"使用Caddy，拥抱HTTP3","date":"2021-11-16","author":"Gao","content":"# 使用Caddy，拥抱HTTP3\n\nHTTP3已经正式发布了一段时间，当前主流浏览器都已经支持http3。\n故而打算使用http3来改善当前的网络服务。\n\n查看了当前可以使用的http3的web服务器，\n当前`nginx`只有发布了测试版本，还没有正式启用，\n目前看可使用的有`traefik`和`caddy`这两个软件。\n\n经过对比选择了使用`caddy`来做web服务器。\n\n## 编译`caddy`\n\n使用caddy，caddy是使用go编写的http服务器。\n需要使用caddy的一些扩展功能的话，需要自己编译caddy，需要使用xcaddy工具来创建版本。\n\n这里我使用了docker中的xcaddy来进行创建，由于使用了golang，可以很方便的交叉编译，创建其它系统平台架构的caddy服务。\n\nxcaddy编译代码：\n\n```bash\nxcaddy build {version} \\\n    --with github.com/caddy-dns/cloudflare \\\n    --with github.com/caddy-dns/route53 \\\n    --with github.com/caddy-dns/vultr \\\n    --with github.com/mholt/caddy-webdav\n```\n\ncaddy使用go开发，可以自己开发caddy的插件来完成需要的功能。\n可以参考官方的文档 [Extending Caddy](https://caddyserver.com/docs/extending-caddy) 进行开发。\n\n这里我使用了`cloudflare`和`route53`的dns服务来进行域名解析，所以添加了这两个模块。\n\n## 使用`caddy`\n\ncaddy使用非常简单，并且可以使用api进行配置，不需要重启。\n\n启动`caddy`\n\n```bash\ncaddy start\n```\n\ncaddy 启动回自动加载当前目录下的 Caddyfile，启动服务。\n\n**常用命令**\n\n- `caddy fmt` Formats a Caddyfile\n\n- `caddy help` View help for caddy commands\n\n- `caddy list-modules` Lists the installed Caddy modules\n\n- `caddy reload` Changes the config of the running Caddy process\n\n- `caddy run` Starts the Caddy process in the foreground\n\n- `caddy start` Starts the Caddy process in the background\n\n- `caddy stop` Stops the running Caddy process\n\n- `caddy trust` Installs a certificate into local trust store(s)\n\n- `caddy untrust` Untrusts a certificate from local trust store(s)\n\n- `caddy validate` Tests whether a config file is valid\n\n- `caddy version` Prints the version\n\n\n配置文件`Caddyfile`\n\n```conf\n{\n    # General Options\n    # debug\n    http_port  80\n    https_port 443\n\n    # TLS Options\n    auto_https disable_redirects\n    email gsmlg.com@gmail.com\n\n    skip_install_trust\n\n    # acme_ca https://acme-staging-v02.api.letsencrypt.org/directory\n    # acme_ca https://acme-v02.api.letsencrypt.org/directory\n    # acme_dns cloudflare {.env.CF_API_TOKEN}\n\n    # Server Options\n    servers {\n        protocol {\n            allow_h2c\n            experimental_http3\n            # strict_sni_host\n        }\n    }\n}\n\n(cloudflare) {\n    tls {\n        ca https://acme-v02.api.letsencrypt.org/directory\n        dns cloudflare {.env.CF_API_TOKEN}\n        resolvers 8.8.8.8 1.1.1.1\n    }\n}\n\n(route53) {\n\ttls {\n        ca https://acme-v02.api.letsencrypt.org/directory\n\t\tdns route53 {\n            max_retries 3\n        }\n\t\tresolvers 8.8.8.8 1.1.1.1\n\t}\n}\n\n*.my-domain.net {\n    import route53\n    @site host some.my-domain.net\n    handle @site {\n        reverse_proxy localhost:8080\n    }\n}\n\n\n*.my-domain.com {\n    import cloudflare\n    @site host some.my-domain.com\n    handle @site {\n        reverse_proxy localhost:8080\n    }\n}\n```\n\n### 使用中遇到的问题\n\n1. `strict_sni_host` 启用后，会导致http3服务无法访问\n\n2. aws配置route53配置\n\n```\n# 环境变量\n\nAWS_ACCESS_KEY_ID='<access key>'\nAWS_SECRET_ACCESS_KEY='<secret key>'\nAWS_HOSTED_ZONE_ID='<zone id>'\nAWS_REGION='<region>'\n\n# or 配置文件放在用户目录下\n\n～/.aws\n\n```\n\n3. cloudflare 配置使用环境变量 `CF_API_TOKEN`\n\n4. 全局配置了`acme_dns`配置，那么所以域名都会默认使用这个方式。\n\n\n\n\n\n\n"}},"__N_SSG":true}