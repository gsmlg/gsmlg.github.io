<!DOCTYPE html><html lang="en"><head><meta name="theme-color" content="#1976d2"/><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>HTTP 请求实体和编码</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/e48649c78aa55d60.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e48649c78aa55d60.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-1fec710eb11e1257.js" defer=""></script><script src="/_next/static/chunks/framework-0f8b31729833af61.js" defer=""></script><script src="/_next/static/chunks/main-e7f9cd3517807e31.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e8de092c0f6b664d.js" defer=""></script><script src="/_next/static/chunks/947-989f03f09a3cc71b.js" defer=""></script><script src="/_next/static/chunks/721-90858fa364933d41.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-51c3d7f318b75bc6.js" defer=""></script><script src="/_next/static/4RPJL9Ob5AKINk71dnYwP/_buildManifest.js" defer=""></script><script src="/_next/static/4RPJL9Ob5AKINk71dnYwP/_ssgManifest.js" defer=""></script><script src="/_next/static/4RPJL9Ob5AKINk71dnYwP/_middlewareManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next"><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-191lty2"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" viewBox="0 0 24 24" aria-hidden="true" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">HTTP 请求实体和编码</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2020-06-09</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><h2>实体和编码</h2>
<p>报文是箱子，实体是货物</p>
<ul>
<li>Example</li>
</ul>
<pre><code class="hljs language-http">http/1.0 200 ok
server: GWS
Content-Type: text/plain
Content-length: 18

Hi! I&#x27;m a message!
</code></pre>
<p>从 Content-type 开始到结束都是实体， header 部分是实体首部， body 部分是实体主体</p>
<p>HTTP 实体首部描述了 HTTP 报文的内容。 HTTP/1.1 版定义了以下 10 个基本字体首部字
段。</p>
<ul>
<li>Content-Type 实体中所承载对象的类型。</li>
<li>Content-Length 所传送实体主体的长度或大小。</li>
<li>Content-Language 与所传送对象最相配的人类语言。</li>
<li>Content-Encoding 对象数据所做的任意变换(比如，压缩)。</li>
<li>Content-Location 一个备用位置，请求时可通过它获得对象。</li>
<li>Content-Range 如果这是部分实体，这个首部说明它是整体的哪个部分。</li>
<li>Content-MD5 实体主体内容的校验和。</li>
<li>Last-Modified 所传输内容在服务器上创建或最后修改的日期时间。</li>
<li>Expires 实体数据将要失效的日期时间。</li>
<li>Allow 该资源所允许的各种请求方法，例如，GET 和 HEAD。</li>
<li>ETag 这份文档特定实例(参见 15.7 节)的唯一验证码。ETag 首部没有正式定义为实 体
首部，但它对许多涉及实体的操作来说，都是一个重要的首部。</li>
<li>Cache-Control 指出应该如何缓存该文档。和 ETag 首部类似，Cache-Control 首部也没
有正 式定义为实体首部。</li>
</ul>
<h3>确定实体主体长度的规则</h3>
<ol>
<li>如果特定的 HTTP 报文类型中不允许带有主体，就忽略 Content-Length 首 部，它是对
(没有实际发送出来的)主体进行计算的。这种情况下，Content- Length 首部是提示性
的，并不说明实际的主体长度。(考虑不周的 HTTP 应用 程序会认为有了
Content-Length 就有主体存在，这样就会出问题。)</li>
</ol>
<p>最重要的例子就是 HEAD 响应。HEAD 方法请求服务器发送等价的 GET 请 求中会出现的首
部，但不要包括主体。因为对 GET 的响应会带有 Content- Length 首部，所以 HEAD 响应
里面也有;但和 GET 响应不同的是，HEAD 响应中不会有主体。1XX、204 以及 304 响应也
可以有提示性的 Content- Length 首部，但是也都没有实体主体。那些规定不能带有实体
主体的报文， 不管带有什么首部字段，都必须在首部之后的第一个空行终止。</p>
<ol start="2">
<li>
<p>如果报文中含有描述传输编码的 Transfer-Encoding 首部(不采用默认的 HTTP“恒等”编
码)，那实体就应由一个称为“零字节块”(zero-byte chunk) 的特殊模式结束，除非报文
已经因连接关闭而结束。我们将在本章后面讨论传 输编码和分块编码。</p>
</li>
<li>
<p>如果报文中含有 Content-Length 首部(并且报文类型允许有实体主体)，而且没有非恒
等的 Transfer-Encoding 首部字段，那么 Content-Length 的值就是主体的长度。如果
收到的报文中既有 Content-Length 首部字段又有非恒等的 Transfer-Encoding 首部字
段，那就必须忽略 Content-Length，因为 传输编码会改变实体主体的表示和传输方式(
因此可能就会改变传输的字节数</p>
</li>
<li>
<p>如果报文使用了 multipart/byteranges(多部分 / 字节范围)媒体类型，并且没有用
Content-Length 首部指出实体主体的长度，那么多部分报文中的每个部 分都要说明它
自己的大小。这种多部分类型是唯一的一种自定界的实体主体类 型，因此除非发送方知
道接收方可以解析它，否则就不能发送这种媒体类型。</p>
</li>
</ol>
<ul>
<li>因为 Range 首部可能会被不理解多部分 / 字节范围的更原始的代理所转发，所以如果发
送方不能确 定接收方是否理解这种自定界的格式的话，就必须用本节的方法(1)、(3)或
(5)来对报文定界。</li>
</ul>
<ol start="5">
<li>如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务 器可以使
用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端</li>
</ol>
<ul>
<li>客户端可以使用半关闭，也就是只把连接的输出端关闭，但很多服务器应用程序设计的时
候没有考虑 到处理这种情况，会把半关闭当作客户端要从服务器断开连接来处理。HTTP
没有对连接管理进行良 好的规范。详情请参见第 4 章。</li>
</ul>
<h3>媒体类型和字符集</h3>
<p>Content-Type 首部字段说明了实体主体的 MIME 类型。 MIME 类型是标准化的名字，用以
说明作为货物运载实体的基本媒体类型。客户端应用程序使用 MIME 类型来解释和处理其
内容。</p>
<p>Content-Type 的值是标准化的 MIME 类型，都在互联网号码分配机构(Internet Assigned
Numbers Authority，简称 IANA)中注册。 MIME 类型由一个主媒体类 型(比如
:text、image 或 audio 等)后面跟一条斜线以及一个子类型组成，子类 型用于进一步描述
媒体类型。</p>
<h3>内容编码</h3>
<p><img src="http-entities-encoding/content-encoding.jpg" alt=""/></p>
<h4>内容编码类型</h4>
<p>HTTP 定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联
网号码分配机构(IANA)对各种编码进行标准化，它给每个内容编码算法分 配了唯一的代号
。</p>
<ul>
<li>gzip RFC1952 gzip 编码</li>
<li>compress Unix 文件压缩</li>
<li>deflate RFC1950 和 1951 讲解 zlib 和 deflate</li>
<li>identity 没有编码</li>
</ul>
<h4>Accept-Encoding</h4>
<p>为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放
在请求的 Accept-Encoding 首部里发出去。如果 HTTP 请求中没有包含 Accept-Encoding
首部，服务器就可以假设客户端能够接受任何编码方式(等价 于发送 Accept-Encoding:
*)。</p>
<p>Example:</p>
<pre><code class="hljs language-http">Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</code></pre>
<p>Q 值的范围从 0.0 到 1.0，0.0 说明客户端不想接受所说明的编码，1.0 则表明最希望使
用的编码。 “*”表示“任何其他方法”。</p>
<h3>传输编码和分块编码</h3>
<p>传输编码也是作用在实体主体上的可逆变换，但使用它们是由 于架构方面的原因，同内容
的格式无关。</p>
<p><img src="http-entities-encoding/transfer-encoding.png" alt=""/></p>
<h4>可靠传输</h4>
<ul>
<li>未知尺寸如果不先生成内容，某些网关应用程序和内容编码器就无法确定报文主体的最终
大小。通常，这些服务器希望在知道大小之前就开始传输数据。因为 HTTP 协议 354 要
求 Content-Length 首部必须在数据之前，有些服务器就使用传输编码来发送数据，并用
特别的结束脚注表明数据结束。</li>
<li>安全性你可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。</li>
</ul>
<h4>Transfer-Encoding Headers</h4>
<ul>
<li>Transfer-Encoding 告知接收方为了可靠地传输报文，已经对其进行了何种编码。</li>
<li>TE 用在请求首部中，告知服务器可以使用哪些传输编码扩展。</li>
</ul>
<p>请求使用了 TE 首部来告诉服务器它可以接受分块编码(如果是 HTTP/1.1 应用程序的话，
这就是必须的)并且愿意接受附在分块编码的报文结尾上的拖挂:</p>
<pre><code class="hljs language-http">GET /new_products.html HTTP/1.1
Host: www.gsmiot.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
...
</code></pre>
<h4>分块编码</h4>
<p>分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送
之前知道整个报文的大小了。</p>
<p><img src="http-entities-encoding/chunked.png" alt=""/></p>
<h3>随时间变化的实例</h3>
<p>HTTP 协议规定了称为实例操控(instance manipulations)的一系列请求和响应操 作，用以
操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两 种方法都要求客
户端能够标识它所拥有(如果有的话)的资源的特定副本，并在一定的条件下请求新的实例。</p>
<h3>验证码和新鲜度</h3>
<p>服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以
用这两个首部之一来提供这种信息:</p>
<ul>
<li>Expires(过期)</li>
<li>Cache- Control(缓存控制)</li>
</ul>
<h4>有条件的请求与验证码</h4>
<table><thead><tr><th>请求类型</th><th>验证码</th><th>描述</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>Last-Modified</td><td>如果在前一条响应的 Last-Modified 首部中说明的 时间之后，资源的版本发生变化，就发送其副本</td></tr><tr><td>If-Unmodified-Since</td><td>Last-Modified</td><td>仅在前一条响应的 Last-Modified 首部中说明的时 间之后，资源的版本没有变化，才发送其副本</td></tr><tr><td>If-Match</td><td>ETag</td><td>如果实体的标记与前一次响应首部中的 ETag 相同， 就发送该资源的副本</td></tr><tr><td>If-None-Match</td><td>ETag</td><td>如果实体的标记与前一次响应首部中的 ETag 不同， 就发送该资源的副本</td></tr></tbody></table>
<h3>范围请求</h3>
<p>有了范围请求，HTTP 客户端可以通过请求曾获取失败的实体的一个范围(或者说 一部分)，
来恢复下载该实体。</p>
<p>Example:</p>
<pre><code class="hljs language-http">GET /bigfile.html HTTP/1.1
Host: www.gsmiot.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
...
</code></pre>
<p>对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多
部分主体及 Content-Type: multipart/byteranges 首部。</p>
<p>服务器可以通过在响应中包含 Accept-Ranges 首部的形式向客户端说明可以接受的范围请
求。这个首部的值是计算范围的单位，通常是以字节计算的。</p>
<h3>差异编码</h3>
<p>差异编码也是一类实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信
息。RFC 3229 描述了差异编码。</p>
<p>如果客户端想告诉服务器它愿意接受该页面的差异，只要发送 A-IM 首部就可以了。 A-IM
是 Accept-Instance-Manipulation(接受实例操控)的缩写。形象比喻的话，客户端相当于
这样说:“哦对了，我能接受某些形式的实例操控，如果你会其中一种的话，就不用发送完整
的文档给我了。” 在 A-IM 首部中，客户端会说明它知道哪些算法可以把差异应用于老版本
而得到最新版本。服务端发送回下面这些内容: 一个特殊的响应代码——226 IM Used，告知
客户端它正在发送的是所请求对象的实例操控，而不是那个完整的对象自身; 一个
IM(Instance-Manipulation 的缩写) 首部，说明用于计算差异的算法; 新的 ETag 首部和
Delta-Base 首部，说明用于计算差异的基线文档的 ETag(理论上，它应该和客户端之前请
求里的 If-None- Match 首部中的 ETag 相同!)。</p>
<p>差异编码所用的首部</p>
<table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>ETag</td><td>文档每个实例的唯一标识符。由服务器在响应中发送;客户端在后继请求的 If-Match 首部和 If-None-Match 首部中可以使用它</td></tr><tr><td>If-None-Match</td><td>客户端发送的请求首部，当且仅当客户端的文档版本与服务器不同时，才向服务 器请求该文档</td></tr><tr><td>A-IM</td><td>客户端请求首部，说明可以接受的实例操控类型</td></tr><tr><td>IM</td><td>服务器响应首部，说明作用在响应上的实例操控的类型。当响应代码是 226 IM Used 时，会发送这个首部</td></tr><tr><td>Delta-Base</td><td>服务器响应首部，说明用于计算差异的基线文档的 ETag 值(应当与客户端请求中的 If-None-Match 首部里的 ETag 相同)</td></tr></tbody></table>
<p><strong>实例操控、差异生成器和差异应用器</strong></p>
<p>客户端可以使用 A-IM 首部说明可以接受的一些实例操控的类型。一些在 IANA 注册的实例
操控类型。</p>
<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>vcdiff</td><td>用 vcdiff 算法计算差异 (vcdiff 的规范由 RFC3284 发布)</td></tr><tr><td>diffe</td><td>用 Unix 系统的 diff-e 命令计算差异</td></tr><tr><td>gdiff</td><td>用 gdiff 算法计算差异 <a href="http://www.w3.org/TR/NOTE-gdiff-19970901.html">link</a></td></tr><tr><td>gzip</td><td>用 gzip 算法压缩</td></tr><tr><td>deflate</td><td>用 deflate 算法压缩</td></tr><tr><td>range</td><td>用在服务器的响应中，说明响应是针对范围选择得到的部分内容</td></tr><tr><td>identity</td><td>用在客户端请求中的 A-IM 首部中，说明客户端愿意接受恒等实例操控</td></tr></tbody></table>
<h3>更多信息</h3>
<p>关于实体和编码方面的更多信息，请参考以下资源。</p>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</a> RFC 2616，也就是 HTTP/1.1 版的规范，是实体
主体管理和编码方面的主要参考。</li>
<li><a href="http://www.ietf.org/rfc/rfc3229.txt">http://www.ietf.org/rfc/rfc3229.txt</a> RFC 3229，“Delta Encoding in HTTP”(“HTTP
中的差异编码”)，说明了如何通 过扩展 HTTP/1.1 来支持差异编码。</li>
<li>Introduction to Data Compression11(《数据压缩导论》) 这本书的作者是 Khalid
Sayood，出版商为 Morgan Kaufmann Publishers。该书介 绍了几种 HTTP 内容编码支持
的压缩算法。</li>
<li><a href="http://www.ietf.org/rfc/rfc1521.txt">http://www.ietf.org/rfc/rfc1521.txt</a> RFC 1521，“Multipurpose Internet Mail
Extensions, Part One: Mechanisms for Specifying and Describing the Format of
Internet Message Bodies”(“ 多 用 途 因 特网邮件扩展，第一部分:规定和描述因特网
报文主体格式的机制”)，描述了 MIME 主体的格式。这份参考材料很有用，因为 HTTP 从
MIME 中借用了大量内容。设计这份文档的目的，就是为了提供在单一报文中包含多个对
象的各种设施，比如用 US-ASCII 之外的字符集来表示主体文本，表示多种字体格式的文
本消息以及表示非文本类的信息，比如图像和声音片段等。</li>
<li><a href="http://www.ietf.org/rfc/rfc2045.txt">http://www.ietf.org/rfc/rfc2045.txt</a> RFC 2045，“Multipurpose Internet Mail
Extensions, Part One: Format of Internet Message Bodies”(“多用途因特网邮件扩展
，第一部分:因特网报文主体的格 式”)，规定了用来描述 MIME 格式报文结构的各种首部
，其中许多都和 HTTP 中的用法类似或相同。</li>
<li><a href="http://www.ietf.org/rfc/rfc1864.txt">http://www.ietf.org/rfc/rfc1864.txt</a> RFC 1864，“The Content-MD5 Header
Field”(“Content-MD5 首部字段”)，提 供了用 Content-MD5 首部字段来做报文完整性检
查的行为及用途方面的一些历史 细节。</li>
<li><a href="http://www.ietf.org/rfc/rfc3230.txt">http://www.ietf.org/rfc/rfc3230.txt</a> RFC 3230，“Instance Digests in HTTP”(“HTTP
中 的 实 例 摘 要 ”)， 描 述 了 对 HTTP 实体摘要处理的改进，解决了 Content-MD5
中存在的各种问题。</li>
</ul></section></div></section><footer style="margin-top:0" class="css-6haedj"><div class="container"><span id="icp-info" class="css-z2a085">京ICP备20014476号-2</span><span>Copyright © 2017-2021 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"http-entities-encoding","blog":{"author":"Gao","content":"## 实体和编码\n\n报文是箱子，实体是货物\n\n- Example\n\n```http\nhttp/1.0 200 ok\nserver: GWS\nContent-Type: text/plain\nContent-length: 18\n\nHi! I'm a message!\n```\n\n从 Content-type 开始到结束都是实体， header 部分是实体首部， body 部分是实体主体\n\nHTTP 实体首部描述了 HTTP 报文的内容。 HTTP/1.1 版定义了以下 10 个基本字体首部字\n段。\n\n- Content-Type 实体中所承载对象的类型。\n- Content-Length 所传送实体主体的长度或大小。\n- Content-Language 与所传送对象最相配的人类语言。\n- Content-Encoding 对象数据所做的任意变换(比如，压缩)。\n- Content-Location 一个备用位置，请求时可通过它获得对象。\n- Content-Range 如果这是部分实体，这个首部说明它是整体的哪个部分。\n- Content-MD5 实体主体内容的校验和。\n- Last-Modified 所传输内容在服务器上创建或最后修改的日期时间。\n- Expires 实体数据将要失效的日期时间。\n- Allow 该资源所允许的各种请求方法，例如，GET 和 HEAD。\n- ETag 这份文档特定实例(参见 15.7 节)的唯一验证码。ETag 首部没有正式定义为实 体\n  首部，但它对许多涉及实体的操作来说，都是一个重要的首部。\n- Cache-Control 指出应该如何缓存该文档。和 ETag 首部类似，Cache-Control 首部也没\n  有正 式定义为实体首部。\n\n### 确定实体主体长度的规则\n\n1. 如果特定的 HTTP 报文类型中不允许带有主体，就忽略 Content-Length 首 部，它是对\n   (没有实际发送出来的)主体进行计算的。这种情况下，Content- Length 首部是提示性\n   的，并不说明实际的主体长度。(考虑不周的 HTTP 应用 程序会认为有了\n   Content-Length 就有主体存在，这样就会出问题。)\n\n最重要的例子就是 HEAD 响应。HEAD 方法请求服务器发送等价的 GET 请 求中会出现的首\n部，但不要包括主体。因为对 GET 的响应会带有 Content- Length 首部，所以 HEAD 响应\n里面也有;但和 GET 响应不同的是，HEAD 响应中不会有主体。1XX、204 以及 304 响应也\n可以有提示性的 Content- Length 首部，但是也都没有实体主体。那些规定不能带有实体\n主体的报文， 不管带有什么首部字段，都必须在首部之后的第一个空行终止。\n\n2. 如果报文中含有描述传输编码的 Transfer-Encoding 首部(不采用默认的 HTTP“恒等”编\n   码)，那实体就应由一个称为“零字节块”(zero-byte chunk) 的特殊模式结束，除非报文\n   已经因连接关闭而结束。我们将在本章后面讨论传 输编码和分块编码。\n\n3. 如果报文中含有 Content-Length 首部(并且报文类型允许有实体主体)，而且没有非恒\n   等的 Transfer-Encoding 首部字段，那么 Content-Length 的值就是主体的长度。如果\n   收到的报文中既有 Content-Length 首部字段又有非恒等的 Transfer-Encoding 首部字\n   段，那就必须忽略 Content-Length，因为 传输编码会改变实体主体的表示和传输方式(\n   因此可能就会改变传输的字节数\n\n4. 如果报文使用了 multipart/byteranges(多部分 / 字节范围)媒体类型，并且没有用\n   Content-Length 首部指出实体主体的长度，那么多部分报文中的每个部 分都要说明它\n   自己的大小。这种多部分类型是唯一的一种自定界的实体主体类 型，因此除非发送方知\n   道接收方可以解析它，否则就不能发送这种媒体类型。\n\n- 因为 Range 首部可能会被不理解多部分 / 字节范围的更原始的代理所转发，所以如果发\n  送方不能确 定接收方是否理解这种自定界的格式的话，就必须用本节的方法(1)、(3)或\n  (5)来对报文定界。\n\n5. 如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务 器可以使\n   用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端\n\n- 客户端可以使用半关闭，也就是只把连接的输出端关闭，但很多服务器应用程序设计的时\n  候没有考虑 到处理这种情况，会把半关闭当作客户端要从服务器断开连接来处理。HTTP\n  没有对连接管理进行良 好的规范。详情请参见第 4 章。\n\n### 媒体类型和字符集\n\nContent-Type 首部字段说明了实体主体的 MIME 类型。 MIME 类型是标准化的名字，用以\n说明作为货物运载实体的基本媒体类型。客户端应用程序使用 MIME 类型来解释和处理其\n内容。\n\nContent-Type 的值是标准化的 MIME 类型，都在互联网号码分配机构(Internet Assigned\nNumbers Authority，简称 IANA)中注册。 MIME 类型由一个主媒体类 型(比如\n:text、image 或 audio 等)后面跟一条斜线以及一个子类型组成，子类 型用于进一步描述\n媒体类型。\n\n### 内容编码\n\n![](http-entities-encoding/content-encoding.jpg)\n\n#### 内容编码类型\n\nHTTP 定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联\n网号码分配机构(IANA)对各种编码进行标准化，它给每个内容编码算法分 配了唯一的代号\n。\n\n- gzip RFC1952 gzip 编码\n- compress Unix 文件压缩\n- deflate RFC1950 和 1951 讲解 zlib 和 deflate\n- identity 没有编码\n\n#### Accept-Encoding\n\n为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放\n在请求的 Accept-Encoding 首部里发出去。如果 HTTP 请求中没有包含 Accept-Encoding\n首部，服务器就可以假设客户端能够接受任何编码方式(等价 于发送 Accept-Encoding:\n\\*)。\n\nExample:\n\n```http\nAccept-Encoding: compress, gzip\nAccept-Encoding:\nAccept-Encoding: *\nAccept-Encoding: compress;q=0.5, gzip;q=1.0\nAccept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n```\n\nQ 值的范围从 0.0 到 1.0，0.0 说明客户端不想接受所说明的编码，1.0 则表明最希望使\n用的编码。 “\\*”表示“任何其他方法”。\n\n### 传输编码和分块编码\n\n传输编码也是作用在实体主体上的可逆变换，但使用它们是由 于架构方面的原因，同内容\n的格式无关。\n\n![](http-entities-encoding/transfer-encoding.png)\n\n#### 可靠传输\n\n- 未知尺寸如果不先生成内容，某些网关应用程序和内容编码器就无法确定报文主体的最终\n  大小。通常，这些服务器希望在知道大小之前就开始传输数据。因为 HTTP 协议 354 要\n  求 Content-Length 首部必须在数据之前，有些服务器就使用传输编码来发送数据，并用\n  特别的结束脚注表明数据结束。\n- 安全性你可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。\n\n#### Transfer-Encoding Headers\n\n- Transfer-Encoding 告知接收方为了可靠地传输报文，已经对其进行了何种编码。\n- TE 用在请求首部中，告知服务器可以使用哪些传输编码扩展。\n\n请求使用了 TE 首部来告诉服务器它可以接受分块编码(如果是 HTTP/1.1 应用程序的话，\n这就是必须的)并且愿意接受附在分块编码的报文结尾上的拖挂:\n\n```http\nGET /new_products.html HTTP/1.1\nHost: www.gsmiot.com\nUser-Agent: Mozilla/4.61 [en] (WinNT; I)\nTE: trailers, chunked\n...\n```\n\n#### 分块编码\n\n分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送\n之前知道整个报文的大小了。\n\n![](http-entities-encoding/chunked.png)\n\n### 随时间变化的实例\n\nHTTP 协议规定了称为实例操控(instance manipulations)的一系列请求和响应操 作，用以\n操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两 种方法都要求客\n户端能够标识它所拥有(如果有的话)的资源的特定副本，并在一定的条件下请求新的实例。\n\n### 验证码和新鲜度\n\n服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以\n用这两个首部之一来提供这种信息:\n\n- Expires(过期)\n- Cache- Control(缓存控制)\n\n#### 有条件的请求与验证码\n\n| 请求类型            | 验证码        | 描述                                                                                     |\n| ------------------- | ------------- | ---------------------------------------------------------------------------------------- |\n| If-Modified-Since   | Last-Modified | 如果在前一条响应的 Last-Modified 首部中说明的 时间之后，资源的版本发生变化，就发送其副本 |\n| If-Unmodified-Since | Last-Modified | 仅在前一条响应的 Last-Modified 首部中说明的时 间之后，资源的版本没有变化，才发送其副本   |\n| If-Match            | ETag          | 如果实体的标记与前一次响应首部中的 ETag 相同， 就发送该资源的副本                        |\n| If-None-Match       | ETag          | 如果实体的标记与前一次响应首部中的 ETag 不同， 就发送该资源的副本                        |\n\n### 范围请求\n\n有了范围请求，HTTP 客户端可以通过请求曾获取失败的实体的一个范围(或者说 一部分)，\n来恢复下载该实体。\n\nExample:\n\n```http\nGET /bigfile.html HTTP/1.1\nHost: www.gsmiot.com\nRange: bytes=4000-\nUser-Agent: Mozilla/4.61 [en] (WinNT; I)\n...\n```\n\n对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多\n部分主体及 Content-Type: multipart/byteranges 首部。\n\n服务器可以通过在响应中包含 Accept-Ranges 首部的形式向客户端说明可以接受的范围请\n求。这个首部的值是计算范围的单位，通常是以字节计算的。\n\n### 差异编码\n\n差异编码也是一类实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信\n息。RFC 3229 描述了差异编码。\n\n如果客户端想告诉服务器它愿意接受该页面的差异，只要发送 A-IM 首部就可以了。 A-IM\n是 Accept-Instance-Manipulation(接受实例操控)的缩写。形象比喻的话，客户端相当于\n这样说:“哦对了，我能接受某些形式的实例操控，如果你会其中一种的话，就不用发送完整\n的文档给我了。” 在 A-IM 首部中，客户端会说明它知道哪些算法可以把差异应用于老版本\n而得到最新版本。服务端发送回下面这些内容: 一个特殊的响应代码——226 IM Used，告知\n客户端它正在发送的是所请求对象的实例操控，而不是那个完整的对象自身; 一个\nIM(Instance-Manipulation 的缩写) 首部，说明用于计算差异的算法; 新的 ETag 首部和\nDelta-Base 首部，说明用于计算差异的基线文档的 ETag(理论上，它应该和客户端之前请\n求里的 If-None- Match 首部中的 ETag 相同!)。\n\n差异编码所用的首部\n\n| 首部          | 描述                                                                                                             |\n| ------------- | ---------------------------------------------------------------------------------------------------------------- |\n| ETag          | 文档每个实例的唯一标识符。由服务器在响应中发送;客户端在后继请求的 If-Match 首部和 If-None-Match 首部中可以使用它 |\n| If-None-Match | 客户端发送的请求首部，当且仅当客户端的文档版本与服务器不同时，才向服务 器请求该文档                              |\n| A-IM          | 客户端请求首部，说明可以接受的实例操控类型                                                                       |\n| IM            | 服务器响应首部，说明作用在响应上的实例操控的类型。当响应代码是 226 IM Used 时，会发送这个首部                    |\n| Delta-Base    | 服务器响应首部，说明用于计算差异的基线文档的 ETag 值(应当与客户端请求中的 If-None-Match 首部里的 ETag 相同)      |\n\n**实例操控、差异生成器和差异应用器**\n\n客户端可以使用 A-IM 首部说明可以接受的一些实例操控的类型。一些在 IANA 注册的实例\n操控类型。\n\n| 类型     | 说明                                                                        |\n| -------- | --------------------------------------------------------------------------- |\n| vcdiff   | 用 vcdiff 算法计算差异 (vcdiff 的规范由 RFC3284 发布)                       |\n| diffe    | 用 Unix 系统的 diff-e 命令计算差异                                          |\n| gdiff    | 用 gdiff 算法计算差异 [link](http://www.w3.org/TR/NOTE-gdiff-19970901.html) |\n| gzip     | 用 gzip 算法压缩                                                            |\n| deflate  | 用 deflate 算法压缩                                                         |\n| range    | 用在服务器的响应中，说明响应是针对范围选择得到的部分内容                    |\n| identity | 用在客户端请求中的 A-IM 首部中，说明客户端愿意接受恒等实例操控              |\n\n### 更多信息\n\n关于实体和编码方面的更多信息，请参考以下资源。\n\n- http://www.ietf.org/rfc/rfc2616.txt RFC 2616，也就是 HTTP/1.1 版的规范，是实体\n  主体管理和编码方面的主要参考。\n- http://www.ietf.org/rfc/rfc3229.txt RFC 3229，“Delta Encoding in HTTP”(“HTTP\n  中的差异编码”)，说明了如何通 过扩展 HTTP/1.1 来支持差异编码。\n- Introduction to Data Compression11(《数据压缩导论》) 这本书的作者是 Khalid\n  Sayood，出版商为 Morgan Kaufmann Publishers。该书介 绍了几种 HTTP 内容编码支持\n  的压缩算法。\n- http://www.ietf.org/rfc/rfc1521.txt RFC 1521，“Multipurpose Internet Mail\n  Extensions, Part One: Mechanisms for Specifying and Describing the Format of\n  Internet Message Bodies”(“ 多 用 途 因 特网邮件扩展，第一部分:规定和描述因特网\n  报文主体格式的机制”)，描述了 MIME 主体的格式。这份参考材料很有用，因为 HTTP 从\n  MIME 中借用了大量内容。设计这份文档的目的，就是为了提供在单一报文中包含多个对\n  象的各种设施，比如用 US-ASCII 之外的字符集来表示主体文本，表示多种字体格式的文\n  本消息以及表示非文本类的信息，比如图像和声音片段等。\n- http://www.ietf.org/rfc/rfc2045.txt RFC 2045，“Multipurpose Internet Mail\n  Extensions, Part One: Format of Internet Message Bodies”(“多用途因特网邮件扩展\n  ，第一部分:因特网报文主体的格 式”)，规定了用来描述 MIME 格式报文结构的各种首部\n  ，其中许多都和 HTTP 中的用法类似或相同。\n- http://www.ietf.org/rfc/rfc1864.txt RFC 1864，“The Content-MD5 Header\n  Field”(“Content-MD5 首部字段”)，提 供了用 Content-MD5 首部字段来做报文完整性检\n  查的行为及用途方面的一些历史 细节。\n- http://www.ietf.org/rfc/rfc3230.txt RFC 3230，“Instance Digests in HTTP”(“HTTP\n  中 的 实 例 摘 要 ”)， 描 述 了 对 HTTP 实体摘要处理的改进，解决了 Content-MD5\n  中存在的各种问题。\n","date":"2020-06-09","id":41,"slug":"http-entities-encoding","title":"HTTP 请求实体和编码"}},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"http-entities-encoding"},"buildId":"4RPJL9Ob5AKINk71dnYwP","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>