<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title>了解Compiler, Tiny compiler</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#1976d2"/><link rel="preload" href="/_next/static/css/b192415249a5ea5e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b192415249a5ea5e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-a287909b40ce69d4.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a5b9b8103dea0669.js" defer=""></script><script src="/_next/static/chunks/eb1842f2-20fe0ca1aebd61de.js" defer=""></script><script src="/_next/static/chunks/947-6c5efbe14cad6a14.js" defer=""></script><script src="/_next/static/chunks/515-af39179dcd4b6b44.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-bf33e1380166809a.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_buildManifest.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_ssgManifest.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_middlewareManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-191lty2"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">了解Compiler, Tiny compiler</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2020-08-02</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><div class="css-1xqzmcn"><p>构建一个简单的编译器, 将 List 格式的代码转换成 C 格式的</p>
<p>原始代码</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">plus</span> <span class="hljs-number">3</span> (<span class="hljs-name">abstract</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span>))
</code></pre>
<h3>编译器</h3>
<p>一个编译器的前端模型</p>
<p><img src="./tiny-compiler/compiler-frontend.jpg" alt="A Compiler&#x27;s Frontend"/></p>
<p>根据编译过程来解决这个问题</p>
<ol>
<li>生成<code>tokens</code></li>
<li>根据<code>tokens</code>生成<code>ast</code></li>
<li>转换<code>ast</code>到<code>newAst</code></li>
<li>从<code>newAst</code>生成代码</li>
</ol>
<h3>Tokenizer</h3>
<p>将源代码转换为<code>token</code>流</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">tokenizer</span> = (<span class="hljs-params">input</span>) =&gt; {
  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> tokens = [];
  <span class="hljs-keyword">while</span> (pos &lt; input.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">let</span> char = input[pos];

    <span class="hljs-keyword">const</span> <span class="hljs-variable hljs-constant">PAREN_MATCH</span> = <span class="hljs-regexp">/[\(\)]/</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable hljs-constant">PAREN_MATCH</span>.<span class="hljs-title hljs-function">test</span>(char)) {
      tokens.<span class="hljs-title hljs-function">push</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;paren&#x27;</span>, <span class="hljs-attr">value</span>: char});
      pos++;
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">const</span> <span class="hljs-variable hljs-constant">NAME_MATCH</span> = <span class="hljs-regexp">/[a-zA-Z_]/</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-variable hljs-constant">NAME_MATCH_</span> = <span class="hljs-regexp">/[a-zA-Z0-9_]/</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable hljs-constant">NAME_MATCH</span>.<span class="hljs-title hljs-function">test</span>(char)) {
      <span class="hljs-keyword">let</span> verb = char;
      <span class="hljs-keyword">while</span> (<span class="hljs-variable hljs-constant">NAME_MATCH_</span>.<span class="hljs-title hljs-function">test</span>(input[++pos])) {
        verb += input[pos];
      }
      tokens.<span class="hljs-title hljs-function">push</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">value</span>: verb});
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">const</span> <span class="hljs-variable hljs-constant">NUM_MATCH</span> = <span class="hljs-regexp">/[0-9]/</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable hljs-constant">NUM_MATCH</span>.<span class="hljs-title hljs-function">test</span>(char)) {
      <span class="hljs-keyword">let</span> verb = char;
      <span class="hljs-keyword">while</span> (<span class="hljs-variable hljs-constant">NUM_MATCH</span>.<span class="hljs-title hljs-function">test</span>(input[++pos])) {
        verb += input[pos];
      }
      tokens.<span class="hljs-title hljs-function">push</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-attr">value</span>: verb});
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">const</span> <span class="hljs-variable hljs-constant">WHITE_SPACE</span> = <span class="hljs-regexp">/\s/</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable hljs-constant">WHITE_SPACE</span>.<span class="hljs-title hljs-function">test</span>(char)) {
      pos++;
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Error</span>(<span class="hljs-string">`Unexpect token at <span class="hljs-subst">${pos}</span>`</span>);
  }
  <span class="hljs-keyword">return</span> tokens;
};

<span class="hljs-variable hljs-language">module</span>.<span class="hljs-property">exports</span> = tokenizer;
</code></pre>
<h3>Parser</h3>
<p>将<code>token</code>流转换为<code>AST</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">parser</span> = (<span class="hljs-params">tokens</span>) =&gt; {
  <span class="hljs-keyword">let</span> current = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">walk</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">let</span> token = tokens[current];

    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;number&#x27;</span>) {
      current++;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>,
        <span class="hljs-attr">value</span>: token.<span class="hljs-property">value</span>,
      };
    }

    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;paren&#x27;</span> &amp;&amp; token.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;(&#x27;</span>) {
      token = tokens[++current];

      <span class="hljs-keyword">let</span> node = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,
        <span class="hljs-attr">name</span>: token.<span class="hljs-property">value</span>,
        <span class="hljs-attr">params</span>: [],
      };

      token = tokens[++current];

      <span class="hljs-keyword">while</span> (
        token.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;paren&#x27;</span> ||
        (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;paren&#x27;</span> &amp;&amp; token.<span class="hljs-property">value</span> !== <span class="hljs-string">&#x27;)&#x27;</span>)
      ) {
        node.<span class="hljs-property">params</span>.<span class="hljs-title hljs-function">push</span>(<span class="hljs-title hljs-function">walk</span>());
        token = tokens[current];
      }

      current++;

      <span class="hljs-keyword">return</span> node;
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">TypeError</span>(token.<span class="hljs-property">type</span>);
  };

  <span class="hljs-keyword">let</span> ast = {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Program&#x27;</span>,
    <span class="hljs-attr">body</span>: [],
  };

  <span class="hljs-keyword">while</span> (current &lt; tokens.<span class="hljs-property">length</span>) {
    ast.<span class="hljs-property">body</span>.<span class="hljs-title hljs-function">push</span>(<span class="hljs-title hljs-function">walk</span>());
  }

  <span class="hljs-keyword">return</span> ast;
};

<span class="hljs-variable hljs-language">module</span>.<span class="hljs-property">exports</span> = parser;
</code></pre>
<h3>Traverser and Transformer</h3>
<p><code>Traverser</code> 提供了遍历 AST 的方法</p>
<p><code>Transformer</code> 通过 <code>Traverser</code> 遍历语法树来修改 <code>AST</code></p>
<h4>Traverser</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">traverser</span> = (<span class="hljs-params">ast, visitor</span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">traverseArray</span> = (<span class="hljs-params">array, parent</span>) =&gt; {
    array.<span class="hljs-title hljs-function">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
      <span class="hljs-title hljs-function">traverseNode</span>(child, parent);
    });
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">traverseNode</span> = (<span class="hljs-params">node, parent</span>) =&gt; {
    <span class="hljs-keyword">let</span> methods = visitor[node.<span class="hljs-property">type</span>];

    <span class="hljs-keyword">if</span> (methods &amp;&amp; methods.<span class="hljs-property">enter</span>) {
      methods.<span class="hljs-title hljs-function">enter</span>(node, parent);
    }

    <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Program&#x27;</span>:
        <span class="hljs-title hljs-function">traverseArray</span>(node.<span class="hljs-property">body</span>, node);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CallExpression&#x27;</span>:
        <span class="hljs-title hljs-function">traverseArray</span>(node.<span class="hljs-property">params</span>, node);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>:
        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">TypeError</span>(node.<span class="hljs-property">type</span>);
    }

    <span class="hljs-keyword">if</span> (methods &amp;&amp; methods.<span class="hljs-property">exit</span>) {
      methods.<span class="hljs-title hljs-function">exit</span>(node, parent);
    }
  };

  <span class="hljs-title hljs-function">traverseNode</span>(ast, <span class="hljs-literal">null</span>);
};

<span class="hljs-variable hljs-language">module</span>.<span class="hljs-property">exports</span> = traverser;
</code></pre>
<h4>Transformer</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> traverser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./traverser&#x27;</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">transformer</span> = (<span class="hljs-params">ast</span>) =&gt; {
  <span class="hljs-keyword">let</span> newAst = {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Program&#x27;</span>,
    <span class="hljs-attr">body</span>: [],
  };

  ast.<span class="hljs-property">_context</span> = newAst.<span class="hljs-property">body</span>;

  <span class="hljs-title hljs-function">traverser</span>(ast, {
    <span class="hljs-title hljs-class">NumberLiteral</span>: {
      <span class="hljs-title hljs-function">enter</span>(<span class="hljs-params">node, parent</span>) {
        parent.<span class="hljs-property">_context</span>.<span class="hljs-title hljs-function">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>,
          <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span>,
        });
      },
    },
    <span class="hljs-title hljs-class">CallExpression</span>: {
      <span class="hljs-title hljs-function">enter</span>(<span class="hljs-params">node, parent</span>) {
        <span class="hljs-keyword">let</span> expression = {
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,
          <span class="hljs-attr">callee</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,
            <span class="hljs-attr">name</span>: node.<span class="hljs-property">name</span>,
          },
          <span class="hljs-attr">arguments</span>: [],
        };

        node.<span class="hljs-property">_context</span> = expression.<span class="hljs-property">arguments</span>;

        <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;CallExpression&#x27;</span>) {
          expression = {
            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ExpressionStatement&#x27;</span>,
            <span class="hljs-attr">expression</span>: expression,
          };
        }

        parent.<span class="hljs-property">_context</span>.<span class="hljs-title hljs-function">push</span>(expression);
      },
    },
  });

  <span class="hljs-keyword">return</span> newAst;
};

<span class="hljs-variable hljs-language">module</span>.<span class="hljs-property">exports</span> = transformer;
</code></pre>
<h3>Code Generator</h3>
<p>将<code>AST</code>重新生成为代码</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">codeGenerator</span> = (<span class="hljs-params">node</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Program&#x27;</span>:
      <span class="hljs-keyword">return</span> node.<span class="hljs-property">body</span>.<span class="hljs-title hljs-function">map</span>(codeGenerator).<span class="hljs-title hljs-function">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ExpressionStatement&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title hljs-function">codeGenerator</span>(node.<span class="hljs-property">expression</span>) + <span class="hljs-string">&#x27;;&#x27;</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CallExpression&#x27;</span>:
      <span class="hljs-keyword">return</span> (
        <span class="hljs-title hljs-function">codeGenerator</span>(node.<span class="hljs-property">callee</span>) +
        <span class="hljs-string">&#x27;(&#x27;</span> +
        node.<span class="hljs-property">arguments</span>.<span class="hljs-title hljs-function">map</span>(codeGenerator).<span class="hljs-title hljs-function">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) +
        <span class="hljs-string">&#x27;)&#x27;</span>
      );

    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Identifier&#x27;</span>:
      <span class="hljs-keyword">return</span> node.<span class="hljs-property">name</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>:
      <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;

    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">TypeError</span>(node.<span class="hljs-property">type</span>);
  }
};

<span class="hljs-variable hljs-language">module</span>.<span class="hljs-property">exports</span> = codeGenerator;
</code></pre></div></section></div></section><footer style="margin-top:0" class="css-6haedj"><div class="container"><span id="icp-info" class="css-z2a085">京ICP备20014476号-2</span><span>Copyright © 2017-2021 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"tiny-compiler","blog":{"author":"Gao","content":"构建一个简单的编译器, 将 List 格式的代码转换成 C 格式的\n\n原始代码\n\n```lisp\n(plus 3 (abstract 9 6))\n```\n\n### 编译器\n\n一个编译器的前端模型\n\n![A Compiler's Frontend](./tiny-compiler/compiler-frontend.jpg)\n\n根据编译过程来解决这个问题\n\n1. 生成`tokens`\n2. 根据`tokens`生成`ast`\n3. 转换`ast`到`newAst`\n4. 从`newAst`生成代码\n\n### Tokenizer\n\n将源代码转换为`token`流\n\n```js\nconst tokenizer = (input) =\u003e {\n  let pos = 0;\n  let tokens = [];\n  while (pos \u003c input.length) {\n    let char = input[pos];\n\n    const PAREN_MATCH = /[\\(\\)]/;\n    if (PAREN_MATCH.test(char)) {\n      tokens.push({type: 'paren', value: char});\n      pos++;\n      continue;\n    }\n\n    const NAME_MATCH = /[a-zA-Z_]/;\n    const NAME_MATCH_ = /[a-zA-Z0-9_]/;\n    if (NAME_MATCH.test(char)) {\n      let verb = char;\n      while (NAME_MATCH_.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({type: 'name', value: verb});\n      continue;\n    }\n\n    const NUM_MATCH = /[0-9]/;\n    if (NUM_MATCH.test(char)) {\n      let verb = char;\n      while (NUM_MATCH.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({type: 'number', value: verb});\n      continue;\n    }\n\n    const WHITE_SPACE = /\\s/;\n    if (WHITE_SPACE.test(char)) {\n      pos++;\n      continue;\n    }\n    throw new Error(`Unexpect token at ${pos}`);\n  }\n  return tokens;\n};\n\nmodule.exports = tokenizer;\n```\n\n### Parser\n\n将`token`流转换为`AST`\n\n```js\nconst parser = (tokens) =\u003e {\n  let current = 0;\n\n  const walk = () =\u003e {\n    let token = tokens[current];\n\n    if (token.type === 'number') {\n      current++;\n\n      return {\n        type: 'NumberLiteral',\n        value: token.value,\n      };\n    }\n\n    if (token.type === 'paren' \u0026\u0026 token.value === '(') {\n      token = tokens[++current];\n\n      let node = {\n        type: 'CallExpression',\n        name: token.value,\n        params: [],\n      };\n\n      token = tokens[++current];\n\n      while (\n        token.type !== 'paren' ||\n        (token.type === 'paren' \u0026\u0026 token.value !== ')')\n      ) {\n        node.params.push(walk());\n        token = tokens[current];\n      }\n\n      current++;\n\n      return node;\n    }\n    throw new TypeError(token.type);\n  };\n\n  let ast = {\n    type: 'Program',\n    body: [],\n  };\n\n  while (current \u003c tokens.length) {\n    ast.body.push(walk());\n  }\n\n  return ast;\n};\n\nmodule.exports = parser;\n```\n\n### Traverser and Transformer\n\n`Traverser` 提供了遍历 AST 的方法\n\n`Transformer` 通过 `Traverser` 遍历语法树来修改 `AST`\n\n#### Traverser\n\n```js\nconst traverser = (ast, visitor) =\u003e {\n  const traverseArray = (array, parent) =\u003e {\n    array.forEach((child) =\u003e {\n      traverseNode(child, parent);\n    });\n  };\n\n  const traverseNode = (node, parent) =\u003e {\n    let methods = visitor[node.type];\n\n    if (methods \u0026\u0026 methods.enter) {\n      methods.enter(node, parent);\n    }\n\n    switch (node.type) {\n      case 'Program':\n        traverseArray(node.body, node);\n        break;\n\n      case 'CallExpression':\n        traverseArray(node.params, node);\n        break;\n\n      case 'NumberLiteral':\n        break;\n\n      default:\n        throw new TypeError(node.type);\n    }\n\n    if (methods \u0026\u0026 methods.exit) {\n      methods.exit(node, parent);\n    }\n  };\n\n  traverseNode(ast, null);\n};\n\nmodule.exports = traverser;\n```\n\n#### Transformer\n\n```js\nconst traverser = require('./traverser');\n\nconst transformer = (ast) =\u003e {\n  let newAst = {\n    type: 'Program',\n    body: [],\n  };\n\n  ast._context = newAst.body;\n\n  traverser(ast, {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value,\n        });\n      },\n    },\n    CallExpression: {\n      enter(node, parent) {\n        let expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: node.name,\n          },\n          arguments: [],\n        };\n\n        node._context = expression.arguments;\n\n        if (parent.type !== 'CallExpression') {\n          expression = {\n            type: 'ExpressionStatement',\n            expression: expression,\n          };\n        }\n\n        parent._context.push(expression);\n      },\n    },\n  });\n\n  return newAst;\n};\n\nmodule.exports = transformer;\n```\n\n### Code Generator\n\n将`AST`重新生成为代码\n\n```js\nconst codeGenerator = (node) =\u003e {\n  switch (node.type) {\n    case 'Program':\n      return node.body.map(codeGenerator).join('\\n');\n\n    case 'ExpressionStatement':\n      return codeGenerator(node.expression) + ';';\n\n    case 'CallExpression':\n      return (\n        codeGenerator(node.callee) +\n        '(' +\n        node.arguments.map(codeGenerator).join(', ') +\n        ')'\n      );\n\n    case 'Identifier':\n      return node.name;\n\n    case 'NumberLiteral':\n      return node.value;\n\n    default:\n      throw new TypeError(node.type);\n  }\n};\n\nmodule.exports = codeGenerator;\n```\n","date":"2020-08-02","id":47,"slug":"tiny-compiler","title":"了解Compiler, Tiny compiler"},"lightCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#c18401}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}","darkCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"tiny-compiler"},"buildId":"18nFAao2IBxASdMZ-oLtx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>