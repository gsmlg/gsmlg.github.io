<!DOCTYPE html><html lang="en"><head><meta name="theme-color" content="#1976d2"/><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>了解Compiler, Tiny compiler</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/f6fff7f38d0ed3d106d5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f6fff7f38d0ed3d106d5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-4de7bd85a1856dba1c5b.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-1f2c591c5d3bfcfc95e6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3edb49d0ad3e50a49500.js" defer=""></script><script src="/_next/static/chunks/880-f1e5c64c8ab4bfd01a1e.js" defer=""></script><script src="/_next/static/chunks/422-b41d874f6ec8aa2163eb.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-512fb50ee27fe1d6bf12.js" defer=""></script><script src="/_next/static/lNHQf-qEKZsFQCCKzYVoG/_buildManifest.js" defer=""></script><script src="/_next/static/lNHQf-qEKZsFQCCKzYVoG/_ssgManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next"><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-191lty2"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" viewBox="0 0 24 24" aria-hidden="true" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">了解Compiler, Tiny compiler</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2020-08-02</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><p>构建一个简单的编译器, 将 List 格式的代码转换成 C 格式的</p>
<p>原始代码</p>
<pre><code class="language-lisp">(plus 3 (abstract 9 6))
</code></pre>
<h3>编译器</h3>
<p>一个编译器的前端模型</p>
<p><img src="./tiny-compiler/compiler-frontend.jpg" alt="A Compiler&#x27;s Frontend"/></p>
<p>根据编译过程来解决这个问题</p>
<ol>
<li>生成<code>tokens</code></li>
<li>根据<code>tokens</code>生成<code>ast</code></li>
<li>转换<code>ast</code>到<code>newAst</code></li>
<li>从<code>newAst</code>生成代码</li>
</ol>
<h3>Tokenizer</h3>
<p>将源代码转换为<code>token</code>流</p>
<pre><code class="language-js">const tokenizer = (input) =&gt; {
  let pos = 0;
  let tokens = [];
  while (pos &lt; input.length) {
    let char = input[pos];

    const PAREN_MATCH = /[\(\)]/;
    if (PAREN_MATCH.test(char)) {
      tokens.push({type: &#x27;paren&#x27;, value: char});
      pos++;
      continue;
    }

    const NAME_MATCH = /[a-zA-Z_]/;
    const NAME_MATCH_ = /[a-zA-Z0-9_]/;
    if (NAME_MATCH.test(char)) {
      let verb = char;
      while (NAME_MATCH_.test(input[++pos])) {
        verb += input[pos];
      }
      tokens.push({type: &#x27;name&#x27;, value: verb});
      continue;
    }

    const NUM_MATCH = /[0-9]/;
    if (NUM_MATCH.test(char)) {
      let verb = char;
      while (NUM_MATCH.test(input[++pos])) {
        verb += input[pos];
      }
      tokens.push({type: &#x27;number&#x27;, value: verb});
      continue;
    }

    const WHITE_SPACE = /\s/;
    if (WHITE_SPACE.test(char)) {
      pos++;
      continue;
    }
    throw new Error(`Unexpect token at ${pos}`);
  }
  return tokens;
};

module.exports = tokenizer;
</code></pre>
<h3>Parser</h3>
<p>将<code>token</code>流转换为<code>AST</code></p>
<pre><code class="language-js">const parser = (tokens) =&gt; {
  let current = 0;

  const walk = () =&gt; {
    let token = tokens[current];

    if (token.type === &#x27;number&#x27;) {
      current++;

      return {
        type: &#x27;NumberLiteral&#x27;,
        value: token.value,
      };
    }

    if (token.type === &#x27;paren&#x27; &amp;&amp; token.value === &#x27;(&#x27;) {
      token = tokens[++current];

      let node = {
        type: &#x27;CallExpression&#x27;,
        name: token.value,
        params: [],
      };

      token = tokens[++current];

      while (
        token.type !== &#x27;paren&#x27; ||
        (token.type === &#x27;paren&#x27; &amp;&amp; token.value !== &#x27;)&#x27;)
      ) {
        node.params.push(walk());
        token = tokens[current];
      }

      current++;

      return node;
    }
    throw new TypeError(token.type);
  };

  let ast = {
    type: &#x27;Program&#x27;,
    body: [],
  };

  while (current &lt; tokens.length) {
    ast.body.push(walk());
  }

  return ast;
};

module.exports = parser;
</code></pre>
<h3>Traverser and Transformer</h3>
<p><code>Traverser</code> 提供了遍历 AST 的方法</p>
<p><code>Transformer</code> 通过 <code>Traverser</code> 遍历语法树来修改 <code>AST</code></p>
<h4>Traverser</h4>
<pre><code class="language-js">const traverser = (ast, visitor) =&gt; {
  const traverseArray = (array, parent) =&gt; {
    array.forEach((child) =&gt; {
      traverseNode(child, parent);
    });
  };

  const traverseNode = (node, parent) =&gt; {
    let methods = visitor[node.type];

    if (methods &amp;&amp; methods.enter) {
      methods.enter(node, parent);
    }

    switch (node.type) {
      case &#x27;Program&#x27;:
        traverseArray(node.body, node);
        break;

      case &#x27;CallExpression&#x27;:
        traverseArray(node.params, node);
        break;

      case &#x27;NumberLiteral&#x27;:
        break;

      default:
        throw new TypeError(node.type);
    }

    if (methods &amp;&amp; methods.exit) {
      methods.exit(node, parent);
    }
  };

  traverseNode(ast, null);
};

module.exports = traverser;
</code></pre>
<h4>Transformer</h4>
<pre><code class="language-js">const traverser = require(&#x27;./traverser&#x27;);

const transformer = (ast) =&gt; {
  let newAst = {
    type: &#x27;Program&#x27;,
    body: [],
  };

  ast._context = newAst.body;

  traverser(ast, {
    NumberLiteral: {
      enter(node, parent) {
        parent._context.push({
          type: &#x27;NumberLiteral&#x27;,
          value: node.value,
        });
      },
    },
    CallExpression: {
      enter(node, parent) {
        let expression = {
          type: &#x27;CallExpression&#x27;,
          callee: {
            type: &#x27;Identifier&#x27;,
            name: node.name,
          },
          arguments: [],
        };

        node._context = expression.arguments;

        if (parent.type !== &#x27;CallExpression&#x27;) {
          expression = {
            type: &#x27;ExpressionStatement&#x27;,
            expression: expression,
          };
        }

        parent._context.push(expression);
      },
    },
  });

  return newAst;
};

module.exports = transformer;
</code></pre>
<h3>Code Generator</h3>
<p>将<code>AST</code>重新生成为代码</p>
<pre><code class="language-js">const codeGenerator = (node) =&gt; {
  switch (node.type) {
    case &#x27;Program&#x27;:
      return node.body.map(codeGenerator).join(&#x27;\n&#x27;);

    case &#x27;ExpressionStatement&#x27;:
      return codeGenerator(node.expression) + &#x27;;&#x27;;

    case &#x27;CallExpression&#x27;:
      return (
        codeGenerator(node.callee) +
        &#x27;(&#x27; +
        node.arguments.map(codeGenerator).join(&#x27;, &#x27;) +
        &#x27;)&#x27;
      );

    case &#x27;Identifier&#x27;:
      return node.name;

    case &#x27;NumberLiteral&#x27;:
      return node.value;

    default:
      throw new TypeError(node.type);
  }
};

module.exports = codeGenerator;
</code></pre></section></div></section><footer class="css-6haedj"><div class="container"><span>Copyright © 2017-2021 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"tiny-compiler","blog":{"id":47,"name":"tiny-compiler","title":"了解Compiler, Tiny compiler","date":"2020-08-02","author":"Gao","content":"构建一个简单的编译器, 将 List 格式的代码转换成 C 格式的\n\n原始代码\n\n```lisp\n(plus 3 (abstract 9 6))\n```\n\n### 编译器\n\n一个编译器的前端模型\n\n![A Compiler's Frontend](./tiny-compiler/compiler-frontend.jpg)\n\n根据编译过程来解决这个问题\n\n1. 生成`tokens`\n2. 根据`tokens`生成`ast`\n3. 转换`ast`到`newAst`\n4. 从`newAst`生成代码\n\n### Tokenizer\n\n将源代码转换为`token`流\n\n```js\nconst tokenizer = (input) =\u003e {\n  let pos = 0;\n  let tokens = [];\n  while (pos \u003c input.length) {\n    let char = input[pos];\n\n    const PAREN_MATCH = /[\\(\\)]/;\n    if (PAREN_MATCH.test(char)) {\n      tokens.push({type: 'paren', value: char});\n      pos++;\n      continue;\n    }\n\n    const NAME_MATCH = /[a-zA-Z_]/;\n    const NAME_MATCH_ = /[a-zA-Z0-9_]/;\n    if (NAME_MATCH.test(char)) {\n      let verb = char;\n      while (NAME_MATCH_.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({type: 'name', value: verb});\n      continue;\n    }\n\n    const NUM_MATCH = /[0-9]/;\n    if (NUM_MATCH.test(char)) {\n      let verb = char;\n      while (NUM_MATCH.test(input[++pos])) {\n        verb += input[pos];\n      }\n      tokens.push({type: 'number', value: verb});\n      continue;\n    }\n\n    const WHITE_SPACE = /\\s/;\n    if (WHITE_SPACE.test(char)) {\n      pos++;\n      continue;\n    }\n    throw new Error(`Unexpect token at ${pos}`);\n  }\n  return tokens;\n};\n\nmodule.exports = tokenizer;\n```\n\n### Parser\n\n将`token`流转换为`AST`\n\n```js\nconst parser = (tokens) =\u003e {\n  let current = 0;\n\n  const walk = () =\u003e {\n    let token = tokens[current];\n\n    if (token.type === 'number') {\n      current++;\n\n      return {\n        type: 'NumberLiteral',\n        value: token.value,\n      };\n    }\n\n    if (token.type === 'paren' \u0026\u0026 token.value === '(') {\n      token = tokens[++current];\n\n      let node = {\n        type: 'CallExpression',\n        name: token.value,\n        params: [],\n      };\n\n      token = tokens[++current];\n\n      while (\n        token.type !== 'paren' ||\n        (token.type === 'paren' \u0026\u0026 token.value !== ')')\n      ) {\n        node.params.push(walk());\n        token = tokens[current];\n      }\n\n      current++;\n\n      return node;\n    }\n    throw new TypeError(token.type);\n  };\n\n  let ast = {\n    type: 'Program',\n    body: [],\n  };\n\n  while (current \u003c tokens.length) {\n    ast.body.push(walk());\n  }\n\n  return ast;\n};\n\nmodule.exports = parser;\n```\n\n### Traverser and Transformer\n\n`Traverser` 提供了遍历 AST 的方法\n\n`Transformer` 通过 `Traverser` 遍历语法树来修改 `AST`\n\n#### Traverser\n\n```js\nconst traverser = (ast, visitor) =\u003e {\n  const traverseArray = (array, parent) =\u003e {\n    array.forEach((child) =\u003e {\n      traverseNode(child, parent);\n    });\n  };\n\n  const traverseNode = (node, parent) =\u003e {\n    let methods = visitor[node.type];\n\n    if (methods \u0026\u0026 methods.enter) {\n      methods.enter(node, parent);\n    }\n\n    switch (node.type) {\n      case 'Program':\n        traverseArray(node.body, node);\n        break;\n\n      case 'CallExpression':\n        traverseArray(node.params, node);\n        break;\n\n      case 'NumberLiteral':\n        break;\n\n      default:\n        throw new TypeError(node.type);\n    }\n\n    if (methods \u0026\u0026 methods.exit) {\n      methods.exit(node, parent);\n    }\n  };\n\n  traverseNode(ast, null);\n};\n\nmodule.exports = traverser;\n```\n\n#### Transformer\n\n```js\nconst traverser = require('./traverser');\n\nconst transformer = (ast) =\u003e {\n  let newAst = {\n    type: 'Program',\n    body: [],\n  };\n\n  ast._context = newAst.body;\n\n  traverser(ast, {\n    NumberLiteral: {\n      enter(node, parent) {\n        parent._context.push({\n          type: 'NumberLiteral',\n          value: node.value,\n        });\n      },\n    },\n    CallExpression: {\n      enter(node, parent) {\n        let expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: node.name,\n          },\n          arguments: [],\n        };\n\n        node._context = expression.arguments;\n\n        if (parent.type !== 'CallExpression') {\n          expression = {\n            type: 'ExpressionStatement',\n            expression: expression,\n          };\n        }\n\n        parent._context.push(expression);\n      },\n    },\n  });\n\n  return newAst;\n};\n\nmodule.exports = transformer;\n```\n\n### Code Generator\n\n将`AST`重新生成为代码\n\n```js\nconst codeGenerator = (node) =\u003e {\n  switch (node.type) {\n    case 'Program':\n      return node.body.map(codeGenerator).join('\\n');\n\n    case 'ExpressionStatement':\n      return codeGenerator(node.expression) + ';';\n\n    case 'CallExpression':\n      return (\n        codeGenerator(node.callee) +\n        '(' +\n        node.arguments.map(codeGenerator).join(', ') +\n        ')'\n      );\n\n    case 'Identifier':\n      return node.name;\n\n    case 'NumberLiteral':\n      return node.value;\n\n    default:\n      throw new TypeError(node.type);\n  }\n};\n\nmodule.exports = codeGenerator;\n```\n"}},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"tiny-compiler"},"buildId":"lNHQf-qEKZsFQCCKzYVoG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>