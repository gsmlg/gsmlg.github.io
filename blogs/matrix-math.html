<!DOCTYPE html><html lang="en"><head><meta name="theme-color" content="#1976d2"/><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>Web中的矩阵变换计算</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b192415249a5ea5e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b192415249a5ea5e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-1fec710eb11e1257.js" defer=""></script><script src="/_next/static/chunks/framework-0f8b31729833af61.js" defer=""></script><script src="/_next/static/chunks/main-e7f9cd3517807e31.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e54de001e0818968.js" defer=""></script><script src="/_next/static/chunks/650-2774057cbd5d0239.js" defer=""></script><script src="/_next/static/chunks/301-4caaf5c3df1c8949.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-0a1bfc61bcd0f7ce.js" defer=""></script><script src="/_next/static/PyL8wqOAfFarx1qaG-EKV/_buildManifest.js" defer=""></script><script src="/_next/static/PyL8wqOAfFarx1qaG-EKV/_ssgManifest.js" defer=""></script><script src="/_next/static/PyL8wqOAfFarx1qaG-EKV/_middlewareManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next"><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-191lty2"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" viewBox="0 0 24 24" aria-hidden="true" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Web中的矩阵变换计算</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2021-10-09</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><h1>矩阵变换计算</h1>
<p>Web 3d中常常用到矩阵变换，这里记录一下矩阵变换的计算方式</p>
<p>三维变换矩阵，这种矩阵由一个4x4方阵，共16个值组成。
在JavaScript中，可以很方便的用数组表示矩阵。比如典型的单位矩阵。
单位阵乘上一个点或者矩阵， 其结果保持不变。</p>
<p><strong>单位矩阵</strong></p>
<pre><code class="language-javascript">const identityMatrix = [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
];
</code></pre>
<p>三维空间中的点和一个4x4矩阵并不匹配，加上了额外的第四维W。一般来说，把W设为1就可以了。
W维度还有一些额外的用途（<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL model view projection - Web APIs | MDN</a>）。</p>
<p>矩阵与点的对齐</p>
<pre><code class="language-javascript">[1, 0, 0, 0,
 0, 1, 0, 0,
 0, 0, 1, 0,
 0, 0, 0, 1]

[4, 3, 2, 1]
</code></pre>
<h3>定义相乘函数</h3>
<p><strong>矩阵与点相乘</strong></p>
<pre><code class="language-javascript">function multiplyMatrixAndPoint(matrix, point) {

  // 给矩阵的每一部分一个简单的变量名, 列数（c）与行数（r）
  var c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];
  var c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];
  var c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];
  var c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];

  // 定义点坐标
  var x = point[0];
  var y = point[1];
  var z = point[2];
  var w = point[3];

  // 点坐标和第一列对应相乘, 再求和
  var resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);

  // 点坐标和第二列对应相乘, 再求和
  var resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);

  // 点坐标和第三列对应相乘, 再求和
  var resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);

  // 点坐标和第四列对应相乘, 再求和
  var resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);

  return [resultX, resultY, resultZ, resultW]
}

</code></pre>
<p>可以使用这个函数将任意点乘以单位矩阵，还会返回这个点</p>
<pre><code class="language-javascript">// identityResult等于[4,3,2,1]
const identityResult = multiplyMatrixAndPoint(identityMatrix, [4,3,2,1]);
</code></pre>
<p><strong>两个矩阵相乘</strong></p>
<pre><code class="language-javascript">function multiplyMatrices(matrixA, matrixB) {

  // 将第二个矩阵按列切片
  var column0 = [matrixB[0], matrixB[4], matrixB[8], matrixB[12]];
  var column1 = [matrixB[1], matrixB[5], matrixB[9], matrixB[13]];
  var column2 = [matrixB[2], matrixB[6], matrixB[10], matrixB[14]];
  var column3 = [matrixB[3], matrixB[7], matrixB[11], matrixB[15]];

  // 将每列分别和矩阵相乘
  var result0 = multiplyMatrixAndPoint( matrixA, column0 );
  var result1 = multiplyMatrixAndPoint( matrixA, column1 );
  var result2 = multiplyMatrixAndPoint( matrixA, column2 );
  var result3 = multiplyMatrixAndPoint( matrixA, column3 );

  // 把结果重新组合成矩阵
  return [
    result0[0], result1[0], result2[0], result3[0],
    result0[1], result1[1], result2[1], result3[1],
    result0[2], result1[2], result2[2], result3[2],
    result0[3], result1[3], result2[3], result3[3]
  ]
}
</code></pre>
<p>实际计算</p>
<pre><code class="language-javascript">const someMatrix = [
  4, 0, 0, 0,
  0, 3, 0, 0,
  0, 0, 5, 0,
  4, 8, 4, 1
]

const identityMatrix = [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
];

// 返回someMatrix的数组表示
const someMatrixResult = multiplyMatrices(identityMatrix, someMatrix);
</code></pre>
<blockquote>
<p>这些函数是为了介绍计算方式而创建的，计算过程创建了大量的数组，性能很差，真实场景计算需要使用TypedArray来做计算。可以使用矩阵计算库 <a href="https://github.com/toji/gl-matrix">GitHub - toji/gl-matrix: Javascript Matrix and Vector library for High Performance WebGL apps</a></p>
</blockquote>
<h3>平移矩阵</h3>
<p>平移矩阵基于单位矩阵。它将一个对象沿x，y，z其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯。咖啡杯必须保持直立和朝向以免咖啡洒出来。它可以离开桌子在空间中移动。</p>
<p>现在我们还喝不到这个杯子里的咖啡，因为在平移矩阵的单独作用下杯子并不能倾斜。在之后的部分，我们会讨论新的矩阵，来解决这个问题。</p>
<pre><code class="language-javascript">const x = 50;
const y = 100;
const z = 0;

const translationMatrix = [
    1,    0,    0,   0,
    0,    1,    0,   0,
    0,    0,    1,   0,
    x,    y,    z,   1
];
</code></pre>
<h3>缩放矩阵</h3>
<p>缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中， 这将使得x，y，z坐标拉伸或收缩。</p>
<pre><code class="language-javascript">var w = 1.5; // width  (x)
var h = 0.7; // height (y)
var d = 1;   // depth  (z)

var scaleMatrix = [
    w,    0,    0,   0,
    0,    h,    0,   0,
    0,    0,    d,   0,
    0,    0,    0,   1
];
</code></pre>
<h3>旋转矩阵</h3>
<pre><code class="language-javascript">const { sin, cos } = Math;

function rotateAroundXAxis(a) {

  return [
       1,       0,        0,     0,
       0,  cos(a),  -sin(a),     0,
       0,  sin(a),   cos(a),     0,
       0,       0,        0,     1
  ];
}

function rotateAroundYAxis(a) {

  return [
     cos(a),   0, sin(a),   0,
          0,   1,      0,   0,
    -sin(a),   0, cos(a),   0,
          0,   0,      0,   1
  ];
}

function rotateAroundZAxis(a) {

  return [
    cos(a), -sin(a),    0,    0,
    sin(a),  cos(a),    0,    0,
         0,       0,    1,    0,
         0,       0,    0,    1
  ];
}
</code></pre>
<h3>矩阵组合</h3>
<p>矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。</p>
<p>矩阵相乘的结果与顺序有关。两个数相乘时，a * b = c, 和 b * a = c 都是正确的。例如，3 * 4 = 12, 和 4 * 3 = 12。在数学上这些数被称为<strong>可交换</strong>。矩阵不能保证交换顺序后的运算结果，所以矩阵是<strong>不可交换</strong>的。</p>
<p>另一个需要记住的点是在WebGL和CSS3中的矩阵相乘需要和变换发生的顺序相反。例如，缩放对象到80%，向下移动200像素，然后绕原点旋转90度在伪代码中应该像下面这样。</p>
<pre><code class="language-javascript">transformation = rotate * translate * scale
</code></pre></section></div></section><footer style="margin-top:0" class="css-6haedj"><div class="container"><span id="icp-info" class="css-z2a085">京ICP备20014476号-2</span><span>Copyright © 2017-2021 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"matrix-math","blog":{"id":53,"name":"matrix-math","title":"Web中的矩阵变换计算","date":"2021-10-09","author":"Gao","content":"# 矩阵变换计算\n\nWeb 3d中常常用到矩阵变换，这里记录一下矩阵变换的计算方式\n\n三维变换矩阵，这种矩阵由一个4x4方阵，共16个值组成。\n在JavaScript中，可以很方便的用数组表示矩阵。比如典型的单位矩阵。\n单位阵乘上一个点或者矩阵， 其结果保持不变。\n\n**单位矩阵**\n```javascript\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n```\n\n三维空间中的点和一个4x4矩阵并不匹配，加上了额外的第四维W。一般来说，把W设为1就可以了。\nW维度还有一些额外的用途（[WebGL model view projection - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection)）。\n\n矩阵与点的对齐\n```javascript\n[1, 0, 0, 0,\n 0, 1, 0, 0,\n 0, 0, 1, 0,\n 0, 0, 0, 1]\n\n[4, 3, 2, 1]\n```\n\n\n### 定义相乘函数\n\n**矩阵与点相乘**\n```javascript\nfunction multiplyMatrixAndPoint(matrix, point) {\n\n  // 给矩阵的每一部分一个简单的变量名, 列数（c）与行数（r）\n  var c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];\n  var c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];\n  var c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];\n  var c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\n\n  // 定义点坐标\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = point[3];\n\n  // 点坐标和第一列对应相乘, 再求和\n  var resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\n\n  // 点坐标和第二列对应相乘, 再求和\n  var resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\n\n  // 点坐标和第三列对应相乘, 再求和\n  var resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\n\n  // 点坐标和第四列对应相乘, 再求和\n  var resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\n\n  return [resultX, resultY, resultZ, resultW]\n}\n\n```\n\n可以使用这个函数将任意点乘以单位矩阵，还会返回这个点\n\n```javascript\n// identityResult等于[4,3,2,1]\nconst identityResult = multiplyMatrixAndPoint(identityMatrix, [4,3,2,1]);\n```\n\n**两个矩阵相乘**\n\n```javascript\nfunction multiplyMatrices(matrixA, matrixB) {\n\n  // 将第二个矩阵按列切片\n  var column0 = [matrixB[0], matrixB[4], matrixB[8], matrixB[12]];\n  var column1 = [matrixB[1], matrixB[5], matrixB[9], matrixB[13]];\n  var column2 = [matrixB[2], matrixB[6], matrixB[10], matrixB[14]];\n  var column3 = [matrixB[3], matrixB[7], matrixB[11], matrixB[15]];\n\n  // 将每列分别和矩阵相乘\n  var result0 = multiplyMatrixAndPoint( matrixA, column0 );\n  var result1 = multiplyMatrixAndPoint( matrixA, column1 );\n  var result2 = multiplyMatrixAndPoint( matrixA, column2 );\n  var result3 = multiplyMatrixAndPoint( matrixA, column3 );\n\n  // 把结果重新组合成矩阵\n  return [\n    result0[0], result1[0], result2[0], result3[0],\n    result0[1], result1[1], result2[1], result3[1],\n    result0[2], result1[2], result2[2], result3[2],\n    result0[3], result1[3], result2[3], result3[3]\n  ]\n}\n```\n\n实际计算\n```javascript\nconst someMatrix = [\n  4, 0, 0, 0,\n  0, 3, 0, 0,\n  0, 0, 5, 0,\n  4, 8, 4, 1\n]\n\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n// 返回someMatrix的数组表示\nconst someMatrixResult = multiplyMatrices(identityMatrix, someMatrix);\n```\n\n\u003e 这些函数是为了介绍计算方式而创建的，计算过程创建了大量的数组，性能很差，真实场景计算需要使用TypedArray来做计算。可以使用矩阵计算库 [GitHub - toji/gl-matrix: Javascript Matrix and Vector library for High Performance WebGL apps](https://github.com/toji/gl-matrix)\n\n\n### 平移矩阵\n\n平移矩阵基于单位矩阵。它将一个对象沿x，y，z其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯。咖啡杯必须保持直立和朝向以免咖啡洒出来。它可以离开桌子在空间中移动。\n\n现在我们还喝不到这个杯子里的咖啡，因为在平移矩阵的单独作用下杯子并不能倾斜。在之后的部分，我们会讨论新的矩阵，来解决这个问题。\n\n```javascript\nconst x = 50;\nconst y = 100;\nconst z = 0;\n\nconst translationMatrix = [\n    1,    0,    0,   0,\n    0,    1,    0,   0,\n    0,    0,    1,   0,\n    x,    y,    z,   1\n];\n```\n\n### 缩放矩阵\n\n缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中， 这将使得x，y，z坐标拉伸或收缩。\n\n```javascript\nvar w = 1.5; // width  (x)\nvar h = 0.7; // height (y)\nvar d = 1;   // depth  (z)\n\nvar scaleMatrix = [\n    w,    0,    0,   0,\n    0,    h,    0,   0,\n    0,    0,    d,   0,\n    0,    0,    0,   1\n];\n```\n\n### 旋转矩阵\n\n```javascript\nconst { sin, cos } = Math;\n\nfunction rotateAroundXAxis(a) {\n\n  return [\n       1,       0,        0,     0,\n       0,  cos(a),  -sin(a),     0,\n       0,  sin(a),   cos(a),     0,\n       0,       0,        0,     1\n  ];\n}\n\nfunction rotateAroundYAxis(a) {\n\n  return [\n     cos(a),   0, sin(a),   0,\n          0,   1,      0,   0,\n    -sin(a),   0, cos(a),   0,\n          0,   0,      0,   1\n  ];\n}\n\nfunction rotateAroundZAxis(a) {\n\n  return [\n    cos(a), -sin(a),    0,    0,\n    sin(a),  cos(a),    0,    0,\n         0,       0,    1,    0,\n         0,       0,    0,    1\n  ];\n}\n```\n\n### 矩阵组合\n\n矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。\n\n矩阵相乘的结果与顺序有关。两个数相乘时，a * b = c, 和 b * a = c 都是正确的。例如，3 * 4 = 12, 和 4 * 3 = 12。在数学上这些数被称为**可交换**。矩阵不能保证交换顺序后的运算结果，所以矩阵是**不可交换**的。\n\n另一个需要记住的点是在WebGL和CSS3中的矩阵相乘需要和变换发生的顺序相反。例如，缩放对象到80%，向下移动200像素，然后绕原点旋转90度在伪代码中应该像下面这样。\n\n```javascript\ntransformation = rotate * translate * scale\n```\n\n"}},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"matrix-math"},"buildId":"PyL8wqOAfFarx1qaG-EKV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>