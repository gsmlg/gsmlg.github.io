<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title>Web中的矩阵变换计算</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#1976d2"/><link rel="preload" href="/_next/static/css/b192415249a5ea5e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b192415249a5ea5e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-a287909b40ce69d4.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a5b9b8103dea0669.js" defer=""></script><script src="/_next/static/chunks/eb1842f2-20fe0ca1aebd61de.js" defer=""></script><script src="/_next/static/chunks/947-6c5efbe14cad6a14.js" defer=""></script><script src="/_next/static/chunks/515-af39179dcd4b6b44.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-bf33e1380166809a.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_buildManifest.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_ssgManifest.js" defer=""></script><script src="/_next/static/18nFAao2IBxASdMZ-oLtx/_middlewareManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-191lty2"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Web中的矩阵变换计算</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2021-10-09</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><div class="css-1xqzmcn"><h1>矩阵变换计算</h1>
<p>Web 3d中常常用到矩阵变换，这里记录一下矩阵变换的计算方式</p>
<p>三维变换矩阵，这种矩阵由一个4x4方阵，共16个值组成。
在JavaScript中，可以很方便的用数组表示矩阵。比如典型的单位矩阵。
单位阵乘上一个点或者矩阵， 其结果保持不变。</p>
<p><strong>单位矩阵</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> identityMatrix = [
  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
];
</code></pre>
<p>三维空间中的点和一个4x4矩阵并不匹配，加上了额外的第四维W。一般来说，把W设为1就可以了。
W维度还有一些额外的用途（<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL model view projection - Web APIs | MDN</a>）。</p>
<p>矩阵与点的对齐</p>
<pre><code class="hljs language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,
 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]

[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
</code></pre>
<h3>定义相乘函数</h3>
<p><strong>矩阵与点相乘</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>(<span class="hljs-params">matrix, point</span>) {

  <span class="hljs-comment">// 给矩阵的每一部分一个简单的变量名, 列数（c）与行数（r）</span>
  <span class="hljs-keyword">var</span> c0r0 = matrix[ <span class="hljs-number">0</span>], c1r0 = matrix[ <span class="hljs-number">1</span>], c2r0 = matrix[ <span class="hljs-number">2</span>], c3r0 = matrix[ <span class="hljs-number">3</span>];
  <span class="hljs-keyword">var</span> c0r1 = matrix[ <span class="hljs-number">4</span>], c1r1 = matrix[ <span class="hljs-number">5</span>], c2r1 = matrix[ <span class="hljs-number">6</span>], c3r1 = matrix[ <span class="hljs-number">7</span>];
  <span class="hljs-keyword">var</span> c0r2 = matrix[ <span class="hljs-number">8</span>], c1r2 = matrix[ <span class="hljs-number">9</span>], c2r2 = matrix[<span class="hljs-number">10</span>], c3r2 = matrix[<span class="hljs-number">11</span>];
  <span class="hljs-keyword">var</span> c0r3 = matrix[<span class="hljs-number">12</span>], c1r3 = matrix[<span class="hljs-number">13</span>], c2r3 = matrix[<span class="hljs-number">14</span>], c3r3 = matrix[<span class="hljs-number">15</span>];

  <span class="hljs-comment">// 定义点坐标</span>
  <span class="hljs-keyword">var</span> x = point[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> y = point[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> z = point[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">var</span> w = point[<span class="hljs-number">3</span>];

  <span class="hljs-comment">// 点坐标和第一列对应相乘, 再求和</span>
  <span class="hljs-keyword">var</span> resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);

  <span class="hljs-comment">// 点坐标和第二列对应相乘, 再求和</span>
  <span class="hljs-keyword">var</span> resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);

  <span class="hljs-comment">// 点坐标和第三列对应相乘, 再求和</span>
  <span class="hljs-keyword">var</span> resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);

  <span class="hljs-comment">// 点坐标和第四列对应相乘, 再求和</span>
  <span class="hljs-keyword">var</span> resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);

  <span class="hljs-keyword">return</span> [resultX, resultY, resultZ, resultW]
}

</code></pre>
<p>可以使用这个函数将任意点乘以单位矩阵，还会返回这个点</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// identityResult等于[4,3,2,1]</span>
<span class="hljs-keyword">const</span> identityResult = <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>(identityMatrix, [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);
</code></pre>
<p><strong>两个矩阵相乘</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">multiplyMatrices</span>(<span class="hljs-params">matrixA, matrixB</span>) {

  <span class="hljs-comment">// 将第二个矩阵按列切片</span>
  <span class="hljs-keyword">var</span> column0 = [matrixB[<span class="hljs-number">0</span>], matrixB[<span class="hljs-number">4</span>], matrixB[<span class="hljs-number">8</span>], matrixB[<span class="hljs-number">12</span>]];
  <span class="hljs-keyword">var</span> column1 = [matrixB[<span class="hljs-number">1</span>], matrixB[<span class="hljs-number">5</span>], matrixB[<span class="hljs-number">9</span>], matrixB[<span class="hljs-number">13</span>]];
  <span class="hljs-keyword">var</span> column2 = [matrixB[<span class="hljs-number">2</span>], matrixB[<span class="hljs-number">6</span>], matrixB[<span class="hljs-number">10</span>], matrixB[<span class="hljs-number">14</span>]];
  <span class="hljs-keyword">var</span> column3 = [matrixB[<span class="hljs-number">3</span>], matrixB[<span class="hljs-number">7</span>], matrixB[<span class="hljs-number">11</span>], matrixB[<span class="hljs-number">15</span>]];

  <span class="hljs-comment">// 将每列分别和矩阵相乘</span>
  <span class="hljs-keyword">var</span> result0 = <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>( matrixA, column0 );
  <span class="hljs-keyword">var</span> result1 = <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>( matrixA, column1 );
  <span class="hljs-keyword">var</span> result2 = <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>( matrixA, column2 );
  <span class="hljs-keyword">var</span> result3 = <span class="hljs-title hljs-function">multiplyMatrixAndPoint</span>( matrixA, column3 );

  <span class="hljs-comment">// 把结果重新组合成矩阵</span>
  <span class="hljs-keyword">return</span> [
    result0[<span class="hljs-number">0</span>], result1[<span class="hljs-number">0</span>], result2[<span class="hljs-number">0</span>], result3[<span class="hljs-number">0</span>],
    result0[<span class="hljs-number">1</span>], result1[<span class="hljs-number">1</span>], result2[<span class="hljs-number">1</span>], result3[<span class="hljs-number">1</span>],
    result0[<span class="hljs-number">2</span>], result1[<span class="hljs-number">2</span>], result2[<span class="hljs-number">2</span>], result3[<span class="hljs-number">2</span>],
    result0[<span class="hljs-number">3</span>], result1[<span class="hljs-number">3</span>], result2[<span class="hljs-number">3</span>], result3[<span class="hljs-number">3</span>]
  ]
}
</code></pre>
<p>实际计算</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> someMatrix = [
  <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>
]

<span class="hljs-keyword">const</span> identityMatrix = [
  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
];

<span class="hljs-comment">// 返回someMatrix的数组表示</span>
<span class="hljs-keyword">const</span> someMatrixResult = <span class="hljs-title hljs-function">multiplyMatrices</span>(identityMatrix, someMatrix);
</code></pre>
<blockquote>
<p>这些函数是为了介绍计算方式而创建的，计算过程创建了大量的数组，性能很差，真实场景计算需要使用TypedArray来做计算。可以使用矩阵计算库 <a href="https://github.com/toji/gl-matrix">GitHub - toji/gl-matrix: Javascript Matrix and Vector library for High Performance WebGL apps</a></p>
</blockquote>
<h3>平移矩阵</h3>
<p>平移矩阵基于单位矩阵。它将一个对象沿x，y，z其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯。咖啡杯必须保持直立和朝向以免咖啡洒出来。它可以离开桌子在空间中移动。</p>
<p>现在我们还喝不到这个杯子里的咖啡，因为在平移矩阵的单独作用下杯子并不能倾斜。在之后的部分，我们会讨论新的矩阵，来解决这个问题。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">50</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">100</span>;
<span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;

<span class="hljs-keyword">const</span> translationMatrix = [
    <span class="hljs-number">1</span>,    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>,    <span class="hljs-number">1</span>,    <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,    <span class="hljs-number">1</span>,   <span class="hljs-number">0</span>,
    x,    y,    z,   <span class="hljs-number">1</span>
];
</code></pre>
<h3>缩放矩阵</h3>
<p>缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中， 这将使得x，y，z坐标拉伸或收缩。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> w = <span class="hljs-number">1.5</span>; <span class="hljs-comment">// width  (x)</span>
<span class="hljs-keyword">var</span> h = <span class="hljs-number">0.7</span>; <span class="hljs-comment">// height (y)</span>
<span class="hljs-keyword">var</span> d = <span class="hljs-number">1</span>;   <span class="hljs-comment">// depth  (z)</span>

<span class="hljs-keyword">var</span> scaleMatrix = [
    w,    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>,    h,    <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,    d,   <span class="hljs-number">0</span>,
    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>
];
</code></pre>
<h3>旋转矩阵</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { sin, cos } = <span class="hljs-title hljs-class">Math</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">rotateAroundXAxis</span>(<span class="hljs-params">a</span>) {

  <span class="hljs-keyword">return</span> [
       <span class="hljs-number">1</span>,       <span class="hljs-number">0</span>,        <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,
       <span class="hljs-number">0</span>,  <span class="hljs-title hljs-function">cos</span>(a),  -<span class="hljs-title hljs-function">sin</span>(a),     <span class="hljs-number">0</span>,
       <span class="hljs-number">0</span>,  <span class="hljs-title hljs-function">sin</span>(a),   <span class="hljs-title hljs-function">cos</span>(a),     <span class="hljs-number">0</span>,
       <span class="hljs-number">0</span>,       <span class="hljs-number">0</span>,        <span class="hljs-number">0</span>,     <span class="hljs-number">1</span>
  ];
}

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">rotateAroundYAxis</span>(<span class="hljs-params">a</span>) {

  <span class="hljs-keyword">return</span> [
     <span class="hljs-title hljs-function">cos</span>(a),   <span class="hljs-number">0</span>, <span class="hljs-title hljs-function">sin</span>(a),   <span class="hljs-number">0</span>,
          <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>,      <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,
    -<span class="hljs-title hljs-function">sin</span>(a),   <span class="hljs-number">0</span>, <span class="hljs-title hljs-function">cos</span>(a),   <span class="hljs-number">0</span>,
          <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,      <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>
  ];
}

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">rotateAroundZAxis</span>(<span class="hljs-params">a</span>) {

  <span class="hljs-keyword">return</span> [
    <span class="hljs-title hljs-function">cos</span>(a), -<span class="hljs-title hljs-function">sin</span>(a),    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,
    <span class="hljs-title hljs-function">sin</span>(a),  <span class="hljs-title hljs-function">cos</span>(a),    <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,
         <span class="hljs-number">0</span>,       <span class="hljs-number">0</span>,    <span class="hljs-number">1</span>,    <span class="hljs-number">0</span>,
         <span class="hljs-number">0</span>,       <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,    <span class="hljs-number">1</span>
  ];
}
</code></pre>
<h3>矩阵组合</h3>
<p>矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。</p>
<p>矩阵相乘的结果与顺序有关。两个数相乘时，a * b = c, 和 b * a = c 都是正确的。例如，3 * 4 = 12, 和 4 * 3 = 12。在数学上这些数被称为<strong>可交换</strong>。矩阵不能保证交换顺序后的运算结果，所以矩阵是<strong>不可交换</strong>的。</p>
<p>另一个需要记住的点是在WebGL和CSS3中的矩阵相乘需要和变换发生的顺序相反。例如，缩放对象到80%，向下移动200像素，然后绕原点旋转90度在伪代码中应该像下面这样。</p>
<pre><code class="hljs language-javascript">transformation = rotate * translate * scale
</code></pre></div></section></div></section><footer style="margin-top:0" class="css-6haedj"><div class="container"><span id="icp-info" class="css-z2a085">京ICP备20014476号-2</span><span>Copyright © 2017-2021 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"matrix-math","blog":{"author":"Gao","content":"# 矩阵变换计算\n\nWeb 3d中常常用到矩阵变换，这里记录一下矩阵变换的计算方式\n\n三维变换矩阵，这种矩阵由一个4x4方阵，共16个值组成。\n在JavaScript中，可以很方便的用数组表示矩阵。比如典型的单位矩阵。\n单位阵乘上一个点或者矩阵， 其结果保持不变。\n\n**单位矩阵**\n```javascript\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n```\n\n三维空间中的点和一个4x4矩阵并不匹配，加上了额外的第四维W。一般来说，把W设为1就可以了。\nW维度还有一些额外的用途（[WebGL model view projection - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection)）。\n\n矩阵与点的对齐\n```javascript\n[1, 0, 0, 0,\n 0, 1, 0, 0,\n 0, 0, 1, 0,\n 0, 0, 0, 1]\n\n[4, 3, 2, 1]\n```\n\n\n### 定义相乘函数\n\n**矩阵与点相乘**\n```javascript\nfunction multiplyMatrixAndPoint(matrix, point) {\n\n  // 给矩阵的每一部分一个简单的变量名, 列数（c）与行数（r）\n  var c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];\n  var c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];\n  var c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];\n  var c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\n\n  // 定义点坐标\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = point[3];\n\n  // 点坐标和第一列对应相乘, 再求和\n  var resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\n\n  // 点坐标和第二列对应相乘, 再求和\n  var resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\n\n  // 点坐标和第三列对应相乘, 再求和\n  var resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\n\n  // 点坐标和第四列对应相乘, 再求和\n  var resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\n\n  return [resultX, resultY, resultZ, resultW]\n}\n\n```\n\n可以使用这个函数将任意点乘以单位矩阵，还会返回这个点\n\n```javascript\n// identityResult等于[4,3,2,1]\nconst identityResult = multiplyMatrixAndPoint(identityMatrix, [4,3,2,1]);\n```\n\n**两个矩阵相乘**\n\n```javascript\nfunction multiplyMatrices(matrixA, matrixB) {\n\n  // 将第二个矩阵按列切片\n  var column0 = [matrixB[0], matrixB[4], matrixB[8], matrixB[12]];\n  var column1 = [matrixB[1], matrixB[5], matrixB[9], matrixB[13]];\n  var column2 = [matrixB[2], matrixB[6], matrixB[10], matrixB[14]];\n  var column3 = [matrixB[3], matrixB[7], matrixB[11], matrixB[15]];\n\n  // 将每列分别和矩阵相乘\n  var result0 = multiplyMatrixAndPoint( matrixA, column0 );\n  var result1 = multiplyMatrixAndPoint( matrixA, column1 );\n  var result2 = multiplyMatrixAndPoint( matrixA, column2 );\n  var result3 = multiplyMatrixAndPoint( matrixA, column3 );\n\n  // 把结果重新组合成矩阵\n  return [\n    result0[0], result1[0], result2[0], result3[0],\n    result0[1], result1[1], result2[1], result3[1],\n    result0[2], result1[2], result2[2], result3[2],\n    result0[3], result1[3], result2[3], result3[3]\n  ]\n}\n```\n\n实际计算\n```javascript\nconst someMatrix = [\n  4, 0, 0, 0,\n  0, 3, 0, 0,\n  0, 0, 5, 0,\n  4, 8, 4, 1\n]\n\nconst identityMatrix = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n// 返回someMatrix的数组表示\nconst someMatrixResult = multiplyMatrices(identityMatrix, someMatrix);\n```\n\n\u003e 这些函数是为了介绍计算方式而创建的，计算过程创建了大量的数组，性能很差，真实场景计算需要使用TypedArray来做计算。可以使用矩阵计算库 [GitHub - toji/gl-matrix: Javascript Matrix and Vector library for High Performance WebGL apps](https://github.com/toji/gl-matrix)\n\n\n### 平移矩阵\n\n平移矩阵基于单位矩阵。它将一个对象沿x，y，z其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯。咖啡杯必须保持直立和朝向以免咖啡洒出来。它可以离开桌子在空间中移动。\n\n现在我们还喝不到这个杯子里的咖啡，因为在平移矩阵的单独作用下杯子并不能倾斜。在之后的部分，我们会讨论新的矩阵，来解决这个问题。\n\n```javascript\nconst x = 50;\nconst y = 100;\nconst z = 0;\n\nconst translationMatrix = [\n    1,    0,    0,   0,\n    0,    1,    0,   0,\n    0,    0,    1,   0,\n    x,    y,    z,   1\n];\n```\n\n### 缩放矩阵\n\n缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中， 这将使得x，y，z坐标拉伸或收缩。\n\n```javascript\nvar w = 1.5; // width  (x)\nvar h = 0.7; // height (y)\nvar d = 1;   // depth  (z)\n\nvar scaleMatrix = [\n    w,    0,    0,   0,\n    0,    h,    0,   0,\n    0,    0,    d,   0,\n    0,    0,    0,   1\n];\n```\n\n### 旋转矩阵\n\n```javascript\nconst { sin, cos } = Math;\n\nfunction rotateAroundXAxis(a) {\n\n  return [\n       1,       0,        0,     0,\n       0,  cos(a),  -sin(a),     0,\n       0,  sin(a),   cos(a),     0,\n       0,       0,        0,     1\n  ];\n}\n\nfunction rotateAroundYAxis(a) {\n\n  return [\n     cos(a),   0, sin(a),   0,\n          0,   1,      0,   0,\n    -sin(a),   0, cos(a),   0,\n          0,   0,      0,   1\n  ];\n}\n\nfunction rotateAroundZAxis(a) {\n\n  return [\n    cos(a), -sin(a),    0,    0,\n    sin(a),  cos(a),    0,    0,\n         0,       0,    1,    0,\n         0,       0,    0,    1\n  ];\n}\n```\n\n### 矩阵组合\n\n矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。\n\n矩阵相乘的结果与顺序有关。两个数相乘时，a * b = c, 和 b * a = c 都是正确的。例如，3 * 4 = 12, 和 4 * 3 = 12。在数学上这些数被称为**可交换**。矩阵不能保证交换顺序后的运算结果，所以矩阵是**不可交换**的。\n\n另一个需要记住的点是在WebGL和CSS3中的矩阵相乘需要和变换发生的顺序相反。例如，缩放对象到80%，向下移动200像素，然后绕原点旋转90度在伪代码中应该像下面这样。\n\n```javascript\ntransformation = rotate * translate * scale\n```\n\n","date":"2021-10-09","id":53,"slug":"matrix-math","title":"Web中的矩阵变换计算"},"lightCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#c18401}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}","darkCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"matrix-math"},"buildId":"18nFAao2IBxASdMZ-oLtx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>