<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title>HTTP 内容协商与转码</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#1976d2"/><link rel="preload" href="/_next/static/css/b192415249a5ea5e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b192415249a5ea5e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-a287909b40ce69d4.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-cf8ff3fd67922e70.js" defer=""></script><script src="/_next/static/chunks/eb1842f2-20fe0ca1aebd61de.js" defer=""></script><script src="/_next/static/chunks/835-5815e86091b18905.js" defer=""></script><script src="/_next/static/chunks/723-aecaeca7c52e6e63.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bslug%5D-1d737e9c2d2661c8.js" defer=""></script><script src="/_next/static/2bKl3MU0qcQ1uWwTVRP2b/_buildManifest.js" defer=""></script><script src="/_next/static/2bKl3MU0qcQ1uWwTVRP2b/_ssgManifest.js" defer=""></script><script src="/_next/static/2bKl3MU0qcQ1uWwTVRP2b/_middlewareManifest.js" defer=""></script><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><section class="css-1vqbnt3"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1x7skt0"><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-i6s8oy"><div status="[object Object]" class="css-ad3hhb"></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1l1167e" tabindex="0" type="button" aria-label="Menu"><span class="MuiBadge-root BaseBadge-root css-1rzb3uu"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg><span class="MuiBadge-badge MuiBadge-standard MuiBadge-invisible MuiBadge-anchorOriginTopRight MuiBadge-anchorOriginTopRightRectangular MuiBadge-overlapRectangular BaseBadge-badge BaseBadge-invisible css-1mcnwcn"></span></span></button><p class="MuiTypography-root MuiTypography-body1 css-1ikde92" type="title"><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/">Home</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/blogs">Blog</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/presentations">Presentation</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/tools">Tool</a></button><button class="MuiButton-root MuiButton-text MuiButton-textInherit MuiButton-sizeMedium MuiButton-textSizeMedium MuiButton-colorInherit MuiButtonBase-root  css-b7766g" tabindex="0" type="button"><a href="/games">Game</a></button></p></div></header><section class="css-xxwux"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation4 css-gnirli"><header><h1 class="MuiTypography-root MuiTypography-body1 css-9l3uo3">HTTP 内容协商与转码</h1><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Author:<!-- -->Gao</div><div class="MuiTypography-root MuiTypography-body1 css-9l3uo3">Created At:<!-- -->2020-06-09</div></header><hr class="MuiDivider-root MuiDivider-fullWidth css-39bbo6"/><section class="MuiTypography-root MuiTypography-body1 blog-content css-9l3uo3"><div class="css-1xqzmcn"><h2>内容协商与转码</h2>
<p>一个 URL 常常需要代表若干不同的资源。例如那种需要以多种语言提供其内容的网站站点
。</p>
<p>HTTP 提 供了内容协商方法，允许客户端和服务器作这样的决定。通过这些方法，单一的
URL 就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)。这些不同的版本称
为变体。</p>
<h3>内容协商技术</h3>
<p>共有 3 种不同的方法可以决定服务器上哪个页面最适合客户端:</p>
<ul>
<li>让客户端来选择</li>
<li>服务器自动判定</li>
<li>让中间代理来选</li>
</ul>
<p>这 3 种技术分别称为</p>
<ul>
<li>客户端驱动的协商</li>
<li>服务器驱动的协商</li>
<li>透明协商</li>
</ul>
<table><thead><tr><th>技术</th><th>工作原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>客户端驱动</td><td>客户端发起请求，服务器发送可选项的列表，客户端选择</td><td>在服务器端的实现最容易。客户端可以选择最合适的内容</td><td>增加了时延:为了获得正确的内容，至少要发送两次请求</td></tr><tr><td>服务器驱动</td><td>服务器检查客户端的请求首部集并决定提供哪个版本的页面</td><td>比客户端驱动的协商方式要快。 HTTP 提供了 q 值机制，允许服务器近似匹配，还提供了 Vary 首部供服务器告知下游的设备如何对请求估值</td><td>如果结论不是很明确(比如首部集不匹配)，服务器要做猜测</td></tr><tr><td>透明</td><td>某个中间设备(通常是缓存代理)代表客户端进行请求协商</td><td>免除了 Web 服务器的协商开销。比客户端驱动的协商要快</td><td>关于如何进行透明协商，还没有正式的规范</td></tr></tbody></table>
<h3>客户端驱动的协商</h3>
<p>从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p>
<ul>
<li>
<p>一是发送回一个 HTML 文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</p>
</li>
<li>
<p>另一种方法是发送回 HTTP/1.1 响应时，使用 300 Multiple Choices 响应代码。客户端
浏览器 收到这种响应时，在前一种情况下，会显示一个带有链接的页面; 在后一种情况
下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户
作出的。</p>
</li>
</ul>
<h3>服务器驱动的协商</h3>
<p>有以下两种机制可供 HTTP 服务器评估发送什么响应给客户端比较合适。</p>
<ul>
<li>
<p>检查内容协商首部集。服务器察看客户端发送的 Accept 首部集，设法用相应的 响应首
部与之匹配。</p>
</li>
<li>
<p>根据其他(非内容协商)首部进行变通。例如，服务器可以根据客户端发送的 User-Agent
首部来发送响应。</p>
</li>
</ul>
<h4>内容协商首部集</h4>
<table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>告知服务器发送何种媒体类型</td></tr><tr><td>Accept-Language</td><td>告知服务器发送何种语言</td></tr><tr><td>Accept-Charset</td><td>告知服务器发送何种字符集</td></tr><tr><td>Accept-Encoding</td><td>告知服务器采用何种编码</td></tr></tbody></table>
<p>注意，由于 HTTP 是无状态的协议(表示服务器不会在不同的请求之间追踪客户端 的偏好
)，所以客户端必须在每个请求中都发送其偏好信息。</p>
<h4>内容协商首部中的质量值</h4>
<p>客户端可以发送下列形式的 Accept-Language 首部:</p>
<pre><code class="hljs language-http"><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
</code></pre>
<p>其中 q 值的范围从 0.0 ~ 1.0(0.0 是优先级最低的，而 1.0 是优先级最高的)。上面 列
出的那个首部，说明该客户端最愿意接收荷兰语(缩写为 nl)文档，但英语(缩 写为 en)文
档也行;无论如何，这个客户端都不愿意收到法语(缩写为 fr)或土耳 其语(缩写为 tr)的版
本。</p>
<h4>随其他首部集而变化</h4>
<p>服务器也可以根据其他客户端请求首部集来匹配响应，比如 User-Agent 首部。</p>
<p>在这种情况下，没有 q 值机制可供查找“最近似”的匹配。服务器或者去找完全匹配，或者
简单地有什么就给什么，这取决于服务器的实现。</p>
<p>由于缓存需要尽力提供所缓存文档中正确的“最佳”版本，HTTP 协议定义了服务器在响应中
发送的 Vary 首部。这个首部告知缓存(还有客户端和所有下游的代理)服务器根据哪些首部
来决定发送响应的最佳版本。</p>
<h4>Apache 中的内容协商</h4>
<ol>
<li>使用 type-map 文件</li>
</ol>
<p>可以在服务器的配置文件中设 置 handler 来说明 type-map 文件的后缀名。</p>
<pre><code class="hljs language-apache"><span class="hljs-attribute">AddHandler</span> type-map .var
</code></pre>
<p>这里给出一个 type-map 文件示例:</p>
<pre><code class="hljs language-apache"><span class="hljs-attribute">URI</span>: joes-hardware.html

<span class="hljs-attribute">URI</span>: joes-hardware.en.html
<span class="hljs-attribute">Content</span>-type: text/html
<span class="hljs-attribute">Content</span>-language: en
<span class="hljs-attribute">URI</span>: joes-hardware.fr.de.html
<span class="hljs-attribute">Content</span>-type: text/html;charset=iso-<span class="hljs-number">8859</span>-<span class="hljs-number">2</span>
<span class="hljs-attribute">Content</span>-language: fr, de
</code></pre>
<p>根据这个 type-map 文件， Apache 服务器就知道要发送 joes-hardware.en.html 给请求
英语版的客户端，发送 joes-hardware.fr.de.html 给请求法语版的客户端。 Apache 服务
器也支持质量值，具体信息请参阅它的文档。</p>
<ol start="2">
<li>使用 MultiView</li>
</ol>
<p>为了使用 MultiView，必须在网站目录下的 <code>access.conf</code> 文件中的适当小节
(<!-- -->&lt;Directory&gt;<!-- -->、 <!-- -->&lt;Location&gt;<!-- -->，或 <!-- -->&lt;Files&gt;<!-- -->)使用 OPTION 指令来启用它。</p>
<p>如果启用了 MultiView，而浏览器又请求了名为 joes-hardware 的资源，服务器就会查找
所有名字中含有 joes-hardware 的文件，并为它们创建 type-map 文件。服务器会 根据名
字猜测其对应的内容协商首部集。例如，法语版的 joes-hardware 应当含有 .fr。</p>
<h4>服务器端扩展</h4>
<p>另一种在服务器端实现内容协商的方法是使用服务器端扩展</p>
<h3>透明协商</h3>
<p>透明协商机制试图从服务器上去除服务器驱动协商所需的负载，并用中间代理来代表客户端
以使与客户端的报文交换最小化。假定代理了解客户端的预期，这样就可以代表客户端与服
务器协商(在客户端请求内容的时候，代理已经收到了客户端的预期)。为了支持透明内容协
商，服务器必须有能力告知代理，服务器需要检查哪些请求首部，以便对客户端的请求进行
最佳匹配。 HTTP/1.1 规范中没有定义任何透明协商机制，但定义了 Vary 首部。服务器在
响应中发送了 Vary 首部，以告知中间节点需要使用哪些请求首部进行内容协商。</p>
<p>代理缓存可以为通过单个 URL 访问的文档保存不同的副本。如果服务器把它们的决 策过程
传给缓存，这些代理就能代表服务器与客户端进行协商。缓存同时也是进行 内容转码的好
地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是 一台服务器传来的内
容进行转码。</p>
<h4>进行缓存与备用候选</h4>
<p>对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求 回送的
是正确的已缓存响应，缓存必须应用服务器在回送响应时所用到的大部分决 策逻辑。</p>
<h4>Vary 首部</h4>
<p>HTTP 的 Vary 响应首部中列出了所有客户端请求首部，服务器可用这些首部来选择文档或
产生定制的内容(在常规的内容协商首部集之外的内容)。</p>
<p>例如，若所提供的 文档取决于 User-Agent 首部，Vary 首部就必须包含 User-Agent。</p>
<p>当新的请求到达时，缓存会根据内容协商首部集来寻找最佳匹配。但在把文档提供 给客户
端之前，它必须检查服务器有没有在已缓存响应中发送 Vary 首部。如果有 Vary 首部，那
么新请求中那些首部的值必须与旧的已缓存请求里相应的首部相同。因为服务器可能会根据
客户端请求的首部来改变响应，为了实现透明协商，缓存必须为每个已缓存变体保存客户端
请求首部和相应的服务器响应首部。</p>
<h3>转码</h3>
<p>如果服务器没有能满足客户端需求的文档会怎么样呢?服务器可以给出一个错误响应。但理
论上，服务器可以把现存的文档转换成某种客户端可用的文档。这种选项称为转码。</p>
<h4>格式转换</h4>
<p>格式转换是指将数据从一种格式转换成另一种格式，使之可以被客户端查看。</p>
<ul>
<li>通过 HTML 到 WML 的转换，无线设备就可以访问通常供桌面客户端查看的文档了。</li>
<li>通过慢速连接访问 Web 页面的客户端并不需要接收高分辨率图像，如果通过格式转换降
低图像分辨率和颜色来减小图像文件大小的话，这类客户端就能更容易地查看图像比较丰
富的页面了。</li>
</ul>
<p>格式转换可以由内容协商首部集来驱动，但也能由 User-Agent 首部来驱动。</p>
<h4>信息综合</h4>
<p>从文档中提取关键的信息片段称为信息综合(information synthesis)，这是一种有用的转
码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标
。</p>
<p>根据内容中的关键字对页面分类是更精细的技术，有助于总结文档的精髓。这种技术常用于
Web 页面分类系统中，比如门户网站的 Web 页面目录。</p>
<h4>内容注入</h4>
<p>前面描述的两类转码通常会减少 Web 文档的内容，但还有另一类转换会增加文档的内容，
即内容注入转码。</p>
<p>内容注入转码的例子有自动广告生成器和用户追踪系统。</p>
<h4>转码与静态预生成的对比</h4>
<p>转码的替代做法是在 Web 服务器上建立 Web 页面的不同副本，例如一个是 HTML，一个是
WML; 一个图像分辨率高，一个图像分辨率低; 一个有多媒体内容，一个没有。</p>
<p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。不过有时候其中一些
计算可以由第三方进行，这样就减少了 Web 服务器上的计算负荷——比如可以由代理或缓存
中的外部 Agent 完成转换。</p>
<h3>下一步计划</h3>
<ul>
<li>
<p>HTTP 中的内容协商受到一些性能方面的限制。在各种变体中搜索合适的内容，或尽力“猜
测”最佳匹配，都会有很大开销。有没有什么办法能专注内容协商协议以使这个过程更高
效? RFC 2295 和 RFC2296 尝试着对这个问题进行了研究，以提供透明的 HTTP 内容协商
。</p>
</li>
<li>
<p>HTTP 不是唯一需要进行内容协商的协议。在其他一些情况下，客户端也需要和服务器交
互以便获得对客户端请求来说最好的答案，流媒体和传真就是另外两个 例子。能否在
TCP/IP 应用层协议之上开发出通用的内容协商协议呢?内容协商工作组(Content
Negotiation Working Group)就是专门为这个问题而成立的。这个工作组目前已经停止工
作了，不过它提出了若干个 RFC。</p>
</li>
</ul>
<h3>更多信息</h3>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</a></li>
</ul>
<p>RFC 2616，“Hypertext Transfer Protocol-HTTP/1.1”(“超文本传输协议 HTTP/1.1”)，这
是 HTTP 协议的当前版本，也是 HTTP/1.1 的官方规范。这份规范行文流畅、 组织良好，
是份详实的 HTTP 参考文献。不过对那些希望学习 HTTP 背后的各种 概念和决策动机、弄
清理论与实践不同之处的读者来说，它就不是很理想了。我们希望本书能补足背后的这些概
念，使读者能更好地利用这份规范。</p>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc2295.txt">http://www.ietf.org/rfc/rfc2295.txt</a></li>
</ul>
<p>RFC 2295，“Transparent Content Negotiation in HTTP”(“HTTP 中的透明内容协 商”)，
这是一份备忘录，描述了建立在 HTTP 之上的透明内容协商协议。这份备忘录目前还是实验
性的。</p>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc2296.txt">http://www.ietf.org/rfc/rfc2296.txt</a></li>
</ul>
<p>RFC 2296,“HTTP Remote Variant Selection Algorithm RVSA 1.0”(“HTTP 远程变体选择算
法 RVSA1.0”)，这份备忘录描述了为特定的 HTTP 请求透明地选择“最佳”内容的算法。这份
备忘录目前还是实验性的。</p>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc2936.txt">http://www.ietf.org/rfc/rfc2936.txt</a></li>
</ul>
<p>RFC 2936,“HTTP MIME Type Handler Detection”(“HTTP MIME 类型处理器检 测”)，这份备
忘录描述了一种用来判定浏览器支持的 MIME 类型处理器的方法。如果 Accept 首部不够明
确的话，这种方法就能派上用场。</p>
<ul>
<li><a href="http://www.imc.org/ietf-medfree/index.htm">http://www.imc.org/ietf-medfree/index.htm</a></li>
</ul>
<p>这个链接指向内容协商(简称 CONNEG)工作组网站。该工作组专注于 HTTP、 传真和打印方
面的透明内容协商。这个工作组目前已停止工作。</p></div></section></div></section><footer style="margin-top:0" class="css-6haedj"><div class="container"><span id="icp-info" class="css-z2a085">京ICP备20014476号-2</span><span>Copyright © 2017-2022 GSMLG - Powered by GSMLG Web.</span></div></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"http-content-negotiation","blog":{"author":"Gao","content":"## 内容协商与转码\n\n一个 URL 常常需要代表若干不同的资源。例如那种需要以多种语言提供其内容的网站站点\n。\n\nHTTP 提 供了内容协商方法，允许客户端和服务器作这样的决定。通过这些方法，单一的\nURL 就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)。这些不同的版本称\n为变体。\n\n### 内容协商技术\n\n共有 3 种不同的方法可以决定服务器上哪个页面最适合客户端:\n\n- 让客户端来选择\n- 服务器自动判定\n- 让中间代理来选\n\n这 3 种技术分别称为\n\n- 客户端驱动的协商\n- 服务器驱动的协商\n- 透明协商\n\n| 技术       | 工作原理                                             | 优点                                                                                                                          | 缺点                                                 |\n| ---------- | ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |\n| 客户端驱动 | 客户端发起请求，服务器发送可选项的列表，客户端选择   | 在服务器端的实现最容易。客户端可以选择最合适的内容                                                                            | 增加了时延:为了获得正确的内容，至少要发送两次请求    |\n| 服务器驱动 | 服务器检查客户端的请求首部集并决定提供哪个版本的页面 | 比客户端驱动的协商方式要快。 HTTP 提供了 q 值机制，允许服务器近似匹配，还提供了 Vary 首部供服务器告知下游的设备如何对请求估值 | 如果结论不是很明确(比如首部集不匹配)，服务器要做猜测 |\n| 透明       | 某个中间设备(通常是缓存代理)代表客户端进行请求协商   | 免除了 Web 服务器的协商开销。比客户端驱动的协商要快                                                                           | 关于如何进行透明协商，还没有正式的规范               |\n\n### 客户端驱动的协商\n\n从实现原理上来说，服务器实际上有两种方法为客户端提供选项:\n\n- 一是发送回一个 HTML 文档，里面有到该页面的各种版本的链接和每个版本的描述信息;\n\n- 另一种方法是发送回 HTTP/1.1 响应时，使用 300 Multiple Choices 响应代码。客户端\n  浏览器 收到这种响应时，在前一种情况下，会显示一个带有链接的页面; 在后一种情况\n  下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户\n  作出的。\n\n### 服务器驱动的协商\n\n有以下两种机制可供 HTTP 服务器评估发送什么响应给客户端比较合适。\n\n- 检查内容协商首部集。服务器察看客户端发送的 Accept 首部集，设法用相应的 响应首\n  部与之匹配。\n\n- 根据其他(非内容协商)首部进行变通。例如，服务器可以根据客户端发送的 User-Agent\n  首部来发送响应。\n\n#### 内容协商首部集\n\n| 首部            | 描述                       |\n| --------------- | -------------------------- |\n| Accept          | 告知服务器发送何种媒体类型 |\n| Accept-Language | 告知服务器发送何种语言     |\n| Accept-Charset  | 告知服务器发送何种字符集   |\n| Accept-Encoding | 告知服务器采用何种编码     |\n\n注意，由于 HTTP 是无状态的协议(表示服务器不会在不同的请求之间追踪客户端 的偏好\n)，所以客户端必须在每个请求中都发送其偏好信息。\n\n#### 内容协商首部中的质量值\n\n客户端可以发送下列形式的 Accept-Language 首部:\n\n```http\nAccept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0\n```\n\n其中 q 值的范围从 0.0 ~ 1.0(0.0 是优先级最低的，而 1.0 是优先级最高的)。上面 列\n出的那个首部，说明该客户端最愿意接收荷兰语(缩写为 nl)文档，但英语(缩 写为 en)文\n档也行;无论如何，这个客户端都不愿意收到法语(缩写为 fr)或土耳 其语(缩写为 tr)的版\n本。\n\n#### 随其他首部集而变化\n\n服务器也可以根据其他客户端请求首部集来匹配响应，比如 User-Agent 首部。\n\n在这种情况下，没有 q 值机制可供查找“最近似”的匹配。服务器或者去找完全匹配，或者\n简单地有什么就给什么，这取决于服务器的实现。\n\n由于缓存需要尽力提供所缓存文档中正确的“最佳”版本，HTTP 协议定义了服务器在响应中\n发送的 Vary 首部。这个首部告知缓存(还有客户端和所有下游的代理)服务器根据哪些首部\n来决定发送响应的最佳版本。\n\n#### Apache 中的内容协商\n\n1. 使用 type-map 文件\n\n可以在服务器的配置文件中设 置 handler 来说明 type-map 文件的后缀名。\n\n```apache\nAddHandler type-map .var\n```\n\n这里给出一个 type-map 文件示例:\n\n```apache\nURI: joes-hardware.html\n\nURI: joes-hardware.en.html\nContent-type: text/html\nContent-language: en\nURI: joes-hardware.fr.de.html\nContent-type: text/html;charset=iso-8859-2\nContent-language: fr, de\n```\n\n根据这个 type-map 文件， Apache 服务器就知道要发送 joes-hardware.en.html 给请求\n英语版的客户端，发送 joes-hardware.fr.de.html 给请求法语版的客户端。 Apache 服务\n器也支持质量值，具体信息请参阅它的文档。\n\n2. 使用 MultiView\n\n为了使用 MultiView，必须在网站目录下的 `access.conf` 文件中的适当小节\n(\u003cDirectory\u003e、 \u003cLocation\u003e，或 \u003cFiles\u003e)使用 OPTION 指令来启用它。\n\n如果启用了 MultiView，而浏览器又请求了名为 joes-hardware 的资源，服务器就会查找\n所有名字中含有 joes-hardware 的文件，并为它们创建 type-map 文件。服务器会 根据名\n字猜测其对应的内容协商首部集。例如，法语版的 joes-hardware 应当含有 .fr。\n\n#### 服务器端扩展\n\n另一种在服务器端实现内容协商的方法是使用服务器端扩展\n\n### 透明协商\n\n透明协商机制试图从服务器上去除服务器驱动协商所需的负载，并用中间代理来代表客户端\n以使与客户端的报文交换最小化。假定代理了解客户端的预期，这样就可以代表客户端与服\n务器协商(在客户端请求内容的时候，代理已经收到了客户端的预期)。为了支持透明内容协\n商，服务器必须有能力告知代理，服务器需要检查哪些请求首部，以便对客户端的请求进行\n最佳匹配。 HTTP/1.1 规范中没有定义任何透明协商机制，但定义了 Vary 首部。服务器在\n响应中发送了 Vary 首部，以告知中间节点需要使用哪些请求首部进行内容协商。\n\n代理缓存可以为通过单个 URL 访问的文档保存不同的副本。如果服务器把它们的决 策过程\n传给缓存，这些代理就能代表服务器与客户端进行协商。缓存同时也是进行 内容转码的好\n地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是 一台服务器传来的内\n容进行转码。\n\n#### 进行缓存与备用候选\n\n对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求 回送的\n是正确的已缓存响应，缓存必须应用服务器在回送响应时所用到的大部分决 策逻辑。\n\n#### Vary 首部\n\nHTTP 的 Vary 响应首部中列出了所有客户端请求首部，服务器可用这些首部来选择文档或\n产生定制的内容(在常规的内容协商首部集之外的内容)。\n\n例如，若所提供的 文档取决于 User-Agent 首部，Vary 首部就必须包含 User-Agent。\n\n当新的请求到达时，缓存会根据内容协商首部集来寻找最佳匹配。但在把文档提供 给客户\n端之前，它必须检查服务器有没有在已缓存响应中发送 Vary 首部。如果有 Vary 首部，那\n么新请求中那些首部的值必须与旧的已缓存请求里相应的首部相同。因为服务器可能会根据\n客户端请求的首部来改变响应，为了实现透明协商，缓存必须为每个已缓存变体保存客户端\n请求首部和相应的服务器响应首部。\n\n### 转码\n\n如果服务器没有能满足客户端需求的文档会怎么样呢?服务器可以给出一个错误响应。但理\n论上，服务器可以把现存的文档转换成某种客户端可用的文档。这种选项称为转码。\n\n#### 格式转换\n\n格式转换是指将数据从一种格式转换成另一种格式，使之可以被客户端查看。\n\n- 通过 HTML 到 WML 的转换，无线设备就可以访问通常供桌面客户端查看的文档了。\n- 通过慢速连接访问 Web 页面的客户端并不需要接收高分辨率图像，如果通过格式转换降\n  低图像分辨率和颜色来减小图像文件大小的话，这类客户端就能更容易地查看图像比较丰\n  富的页面了。\n\n格式转换可以由内容协商首部集来驱动，但也能由 User-Agent 首部来驱动。\n\n#### 信息综合\n\n从文档中提取关键的信息片段称为信息综合(information synthesis)，这是一种有用的转\n码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标\n。\n\n根据内容中的关键字对页面分类是更精细的技术，有助于总结文档的精髓。这种技术常用于\nWeb 页面分类系统中，比如门户网站的 Web 页面目录。\n\n#### 内容注入\n\n前面描述的两类转码通常会减少 Web 文档的内容，但还有另一类转换会增加文档的内容，\n即内容注入转码。\n\n内容注入转码的例子有自动广告生成器和用户追踪系统。\n\n#### 转码与静态预生成的对比\n\n转码的替代做法是在 Web 服务器上建立 Web 页面的不同副本，例如一个是 HTML，一个是\nWML; 一个图像分辨率高，一个图像分辨率低; 一个有多媒体内容，一个没有。\n\n对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。不过有时候其中一些\n计算可以由第三方进行，这样就减少了 Web 服务器上的计算负荷——比如可以由代理或缓存\n中的外部 Agent 完成转换。\n\n### 下一步计划\n\n- HTTP 中的内容协商受到一些性能方面的限制。在各种变体中搜索合适的内容，或尽力“猜\n  测”最佳匹配，都会有很大开销。有没有什么办法能专注内容协商协议以使这个过程更高\n  效? RFC 2295 和 RFC2296 尝试着对这个问题进行了研究，以提供透明的 HTTP 内容协商\n  。\n\n- HTTP 不是唯一需要进行内容协商的协议。在其他一些情况下，客户端也需要和服务器交\n  互以便获得对客户端请求来说最好的答案，流媒体和传真就是另外两个 例子。能否在\n  TCP/IP 应用层协议之上开发出通用的内容协商协议呢?内容协商工作组(Content\n  Negotiation Working Group)就是专门为这个问题而成立的。这个工作组目前已经停止工\n  作了，不过它提出了若干个 RFC。\n\n### 更多信息\n\n- http://www.ietf.org/rfc/rfc2616.txt\n\nRFC 2616，“Hypertext Transfer Protocol-HTTP/1.1”(“超文本传输协议 HTTP/1.1”)，这\n是 HTTP 协议的当前版本，也是 HTTP/1.1 的官方规范。这份规范行文流畅、 组织良好，\n是份详实的 HTTP 参考文献。不过对那些希望学习 HTTP 背后的各种 概念和决策动机、弄\n清理论与实践不同之处的读者来说，它就不是很理想了。我们希望本书能补足背后的这些概\n念，使读者能更好地利用这份规范。\n\n- http://www.ietf.org/rfc/rfc2295.txt\n\nRFC 2295，“Transparent Content Negotiation in HTTP”(“HTTP 中的透明内容协 商”)，\n这是一份备忘录，描述了建立在 HTTP 之上的透明内容协商协议。这份备忘录目前还是实验\n性的。\n\n- http://www.ietf.org/rfc/rfc2296.txt\n\nRFC 2296,“HTTP Remote Variant Selection Algorithm RVSA 1.0”(“HTTP 远程变体选择算\n法 RVSA1.0”)，这份备忘录描述了为特定的 HTTP 请求透明地选择“最佳”内容的算法。这份\n备忘录目前还是实验性的。\n\n- http://www.ietf.org/rfc/rfc2936.txt\n\nRFC 2936,“HTTP MIME Type Handler Detection”(“HTTP MIME 类型处理器检 测”)，这份备\n忘录描述了一种用来判定浏览器支持的 MIME 类型处理器的方法。如果 Accept 首部不够明\n确的话，这种方法就能派上用场。\n\n- http://www.imc.org/ietf-medfree/index.htm\n\n这个链接指向内容协商(简称 CONNEG)工作组网站。该工作组专注于 HTTP、 传真和打印方\n面的透明内容协商。这个工作组目前已停止工作。\n","date":"2020-06-09","id":43,"slug":"http-content-negotiation","title":"HTTP 内容协商与转码"},"lightCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#c18401}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}","darkCss":"pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}"},"__N_SSG":true},"page":"/blogs/[slug]","query":{"slug":"http-content-negotiation"},"buildId":"2bKl3MU0qcQ1uWwTVRP2b","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>